Hash Table
(kmitl) cs -departmentCh.13Hash Table
â€¢Array is a data structure 
where random access is O(1)
â€¢Hash table tries to mimic 
such property
â€¢Hash value is computed to 
act as index of array
â€¢Hash table is a collection where data is stored according to a 
computed key calls hash value .
â€¢Hash value computed using hash function
â€¢Hash value  can be computed from data or key to the data
â€¢Hash value indicates where the data belongs in the hash table.
â€¢Example:
â€¢Books can be structured that all books with title starts with the same letter are 
stored in the same bookshelf
â€¢In this case, hash function maps title of the book to the first letter 
of the title
2Hash Table Properties
â€¢Complexities
Algorithms Average Worst case
Space O(n) O(n)
Search O(1) O(n)
Insert O(1) O(n)
Delete O(1) O(n)
3Simple Example
â€¢Store 83, 72, 95, 124, 7, 109 into a hash table 
â€¢Set hash function H(x) = x mod 10
â€¢Hash table = array of 10 intâ€™s
â€¢H(83) = 3
â€¢H(72) = 2
â€¢H(95) = 5
â€¢H(124) = 4
â€¢H(7) = 7
â€¢H(109) = 9
â€¢Everything is nice and simple
â€¢Insert, search, and delete can be done in O(1)0
1
272
383
4124
595
6
77
8
9109
4Hash Table Parameters
â€¢Hash function
â€¢Should be O(1) 
â€¢Maps keys to data to slots in hash table
â€¢The mapping should be spread out (uniform distribution)
â€¢What happen if multiple keys are mapped to the same slot?
â€¢Hash Table 
â€¢Load factor = n / k
â€¢n = number of data, k = number of slot
â€¢Higher load factor = more collision0
1
272
383
4124
595
6
77
8
9109
5What is a good hash function?
1.As random as possible 
â€¢The has function distributes the keys from the universe U uniformly 
over the m slots (out of M slots in 
direct -address array).
â€¢The hash function has to  be as 
independent as possible from patterns 
that might occur in the input.
2.Fast to compute 
6Java .hashcode() 
7
Java .hashcode() 
8
Java .hashcode() 
9
Java .hashcode() 
â€¢E.g. class Person 
10
Classical hashing techniques
â€¢Digit Analysis 
â€¢Multiplicative Hashing 
â€¢Folding
â€¢Modulus Hashing
11Classical hashing techniques
Digit Analysis 
â€¢Concept:
â€¢Examines the digits of the key and selects or rearranges specific ones to 
form the hash.
â€¢How it works: 
â€¢Choose certain digits (e.g., last 4 digits) from the key.
â€¢Use them as the hash value.
â€¢Use case: 
â€¢Effective when keys have non -uniform distributions or common 
prefixes. 
â€¢Example: 
â€¢Key = 123456789  â†’ Hash = 6789  (extract last four digits)
12Classical hashing techniques
Folding Method  
â€¢Concept:
â€¢Divide the key into equal parts, then combine (add or XOR) them to 
produce the hash.
â€¢How it works: 
â€¢Break the key into groups of digits.
â€¢Add or mix the groups together.
â€¢If key length not divisible evenly, adjust the last group.
â€¢Use case: 
â€¢Works well for numeric or long keys. 
â€¢Example: 
â€¢Key = 1234567890  â†’ (123 + 456 + 789 + 0) = 1368
13Classical hashing techniques
Multiplicative Hashing   
â€¢Concept:
â€¢Multiplies the key by a constant fraction and extracts the fractional part.
â€¢How it works: 
â€¢h(k)=âŒŠm (kA â€“ âŒŠkAâŒ‹) âŒ‹
â€¢e.g. A = 0.6180339887 
â€¢m is table size  
â€¢Use case: 
â€¢Gives a uniform distribution and minimizes clustering.
â€¢Example: 
â€¢A=0.618, ğ‘š=1000, ğ‘˜=12345 â”h(k) = 310
14Classical hashing techniques
Modulus Hashing  
â€¢Concept:
â€¢The simplest method â€” use the remainder when the key is divided by 
table size.
â€¢How it works: 
â€¢h(k)=k mod m 
â€¢Use case: 
â€¢Fast and easy; choose ğ‘šm as a prime number close to table size to 
reduce collisions. 
â€¢Good m may not be easy to find.
â€¢Example: 
â€¢Key = 12345, ğ‘š=1000m=1000 â†’ Hash = 345 
15Examples of Hashing Function  
16int h1(int x) {
  return (2654435769 * x) >> 22;
}
int h2(int x) {
  x = ~x + (x << 15); 
  x ^= (x >> 11);
  x += (x << 3);
  x ^= (x >> 5);
  x += (x << 10);
  x ^= (x >> 16);
  return x & 0x3FF;
}k 1 2 3 4 5 6 7 8
h1(k) 632 241 874 483 92 725 334 966
h2(k) 500 1001 507 978 486 1014 403 933Collision Resolution
â€¢Separate Chaining 
â€¢Open Addressing 
â€¢Linear probing
â€¢Quadratic probing
â€¢Double hashing
17Collision Resolution
Separate Chaining
â€¢Example (m = 1000)
 h(k1) = h(k5) = h(k7) = 2 
 h(k2) = 4
 h(k4) = h(k6) = 5
 h(k8) = 996
 h(k9) = h(k3) = 998  
18Collision Resolution
Separate Chaining
â€¢What to do when there are collisions?
â€¢Separate chaining: each slot acts as a collection. 
â€¢Put all the collided data in one 
collection
â€¢Originally use linked list
â€¢Big-O can become O(n)
â€¢In practice, self -balancing BST
is used.
â€¢Better time performance  for the 
worst case: O(log n) 
19Collision Resolution
Open Addressing
â€¢What to do when there are collisions?
â€¢Open Addressing
â€¢A.K.A. closed hashing
â€¢Probe for empty slot to put the 
collided data
â€¢Well -known probe sequence
â€¢Linear probing
â€¢Quadratic probing
â€¢Double hashing
20Linear Probing
â€¢Look for the empty slot next to 
the current slot
â€¢Hash function: ğ»ğ‘–ğ‘¥=ğ»ğ‘¥+ğ‘–
â€¢Where ğ‘– is the number of collision
â€¢(One of the) pseudocode
21Linear Probing
â€¢Deletion:
â€¢Deletion requires marking  slots as deleted 
(lazy deletion) to preserve the probe 
sequence. (clean the marking by calling 
rehash)
â€¢Another choice is to remove everything 
after the deleted item and re -insert them 
back again.
22
https://en.wikipedia.org/wiki/Linear_probing  https://www.cs.emory.edu/~cheung/Courses/253/Syllabus
/Map/open -addr -delete.html  Quadratic Probing
â€¢New â€œjump â€ sequence to avoid Primary Clustering effect
â€¢Works a little better due to Central Limit Theorem.
â€¢Hash function: ğ»ğ‘–ğ‘¥=ğ»ğ‘¥+ğ‘–2
â€¢Where ğ‘– is the number of collision 
â€¢probes for collisions 0, 12, 22, 32 â†’ +1, +4, +9
â€¢If the load factor is too high, an empty slot 
may not be found.
â€¢Managable issue. 
â€¢Note on deletion 
â€¢Deletion requires marking slots as deleted (lazy deletion) to preserve the 
probe sequence.
23
https://www.codingeek.com/data -structure/complete -guide -
open -addressing -classification -eliminate -collisions/  Double Hashing
â€¢Use new hash function for jump sequence
â€¢Hash function: ğ»ğ‘–ğ‘¥=ğ»ğ‘¥+ğ‘–ğ»2(ğ‘¥)
â€¢Where ğ‘– is the number of collision
â€¢ğ‘–ğ»2(ğ‘¥) is a new hash function
â€¢The secondary hash function, ğ»2(ğ‘¥), should:
â€¢never yield an index of zero
â€¢cycle through the whole table (relative prime to number of slots)
â€¢be very fast to compute
â€¢be pair -wise independent of ğ»ğ‘¥
â€¢The distribution characteristics of ğ»2(ğ‘¥) are irrelevant. 
â€¢It is analogous to a random -number generator.
24Comparison of Average Number of ProbesSummary
â€¢A hash table mimics array -like random access using the hash value as 
an index..
â€¢Understanding the key distribution characteristic and/or the key distribution 
of the hash function impacts the hash table performance.
â€¢Collision resolution can be done by separate chaining and open 
addressing .
â€¢For separated chaining, modern implementations often use self -balancing 
BSTs instead of linked lists.
â€¢Open addressing looks for empty slot in the table. Sequence of looking 
(probing) is open for discussion. 
â€¢In open addressing, deletion requires marking a slot as deleted to preserve 
the probe sequence.
26