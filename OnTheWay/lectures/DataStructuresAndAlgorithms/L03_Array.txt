Array
(kmitl) cs -departmentCh.03Outline
â€¢Array Introduction
â€¢Declaration and Instantiation
â€¢Random access (retrieve/update)
â€¢Add/Insert unordered/ordered array
â€¢Search in unordered/ordered array
â€¢Delete unordered/ordered array
â€¢Array Limitation
â€¢Expanding an array 
2Array Introduction
â€¢One of the most basic data 
structure.
â€¢An array (hence the name) of 
data of the same type  referred 
to by a common name.
â€¢Data are put next to each other, 
without any space, in the physical 
memory.
â€¢In JAVA, the data are in heap 
(dynamic memory) of JVM.
3â€¢Starts from variable declaration
byte b[];
â€¢Note that we can write byte[] b;
â€¢Another note, the follow two lines of 
code are not the same:
          byte a[], c; // c is just byte 
          byte[] b, d;// both b and d are 
â€¢Now, create it.
b = new byte[5];
â€¢data are allocated next to each others .
â€¢We can refer to them as b[0]..b[4]
â€¢In C/C++ and some other languages address 
of b is the actual physical memory address. 
So, we can access memory at 
the address (b+2) for b[2].
Declaration and Instantiation
â€¢Letâ€™s assume there are 64 bytes of 
dynamic memory 
4Array Operations
â€¢We are to analyze the following array operation
â€¢Random access (retrieve/update)
â€¢Add/Insert unordered/ordered array
â€¢Search in unordered/ordered array
â€¢Delete unordered/ordered array
5
Process Memory LayoutMyArray.java & ArrayTester.java
MyArray.java
publicclassMyArray {
intMAX_SIZE =5;
intdata[]=newint[MAX_SIZE];
intsize=0;
    // your code here
publicStringtoString (){
StringBuffer sb=newStringBuffer ();
sb.append ("[");
for(int i=0;i<size-1;i++){
sb.append (data[i]);
sb.append (",");
}
if(size>0) sb.append (data[size -1]);
sb.append ("]");
returnsb.toString ();
}
}ArrayTester.java
publicclassArrayTester {
publicstaticvoidmain(String args[]){
MyArray mArray=newMyArray();
        // your test code here
System.out.print (mArray.toString ());
}
}What is the Big -O of 
toString ()?
6MyArray  Setup
â€¢In practice, we do not care
about the actual address.
MyArray.java
publicclassMyArray {
intMAX_SIZE =5;
intdata[]=newint[MAX_SIZE ];
intsize=0;
// more code below here
7Accessing Array Data
â€¢Random access data in arrays 
is done by access array at the 
starting point + index
â€¢Ex: address of data[2] is 
at 1+2 = 3
â€¢In MyArray, we encapsulate 
data by method getAt()/setAt(). 
â€¢This way, we can control what happen
to our data. 
â€¢The figure illustrates getAt(2) which will 
return 8.
â€¢What is the Big -O of setAt()/getAt?getAt() & setAt()
publicintgetAt(inti){
returndata[i];
}
publicvoidsetAt(intd,inti){
data[i]=d;
}8
Method add(int d)
â€¢We want to add a new data into our 
array.
â€¢We do not care about order.
â€¢Best place to put is at the end of array.
â€¢So, we do not have to move any of the old 
data.â€¢Letâ€™s implement this.
Method add() version 1
public void add(int d) {
    data[size]=d;
    size=size+1;
}
Method add() more compact version
public void add(int d) {
    data[size++]=d;
}
9Method isFull() and isEmpty()
â€¢Simple methods, I will just put 
it here
â€¢They are both ğ‘‚(1)
Method isFull()
public boolean isFull() {
    return size==MAX_SIZE;
}
Method isEmpty()
public boolean isEmpty() {
    return size==0;
}â€¢Error Checking
â€¢When to check isFull()/isEmpty()?
â€¢Three ways to do this:
â€¢Before calling the method ( v1)
â€¢In method ( v2)
â€¢Check exception ( v3)
â€¢We will use methods add()  and 
isFull()  for demonstration
â€¢The following ideas are also 
applicable to index out of bound.
10â€¢If you really need performance,
you can leave add() as is and do
the checking yourself.
â€¢fast(?) but need to worry 
programmers
ArrayTester.java
publicclassArrayTester {
publicstaticvoidmain(String args[]){
MyArray mArray=newMyArray();
        /* v1 */
        if(!mArray.isFull ()) 
            mArray.add (5);
System.out.print (mArray.toString ());
}
}Method add() revised
public int add(int d ) {/* v2 */
    if(isFull()) 
        return -1;
    data[size++]=d;
    return size;
}Demonstration on isFull()
â€¢Another implementation 
practice is to return boolean, 
true if successfully added and 
false otherwise.
â€¢It is a good practice to use 
isFull() in place of size == 
MAX_SIZE11ArrayTester.java
publicclassArrayTester {
publicstaticvoidmain(String args[]){
MyArray mArray=newMyArray();
try{ 
mArray.add (3);
mArray.add (7);
mArray.add (5);
mArray.add (4);
mArray.add (6);
mArray.add (1);
}catch(MyArray.IsFullException e){
//errorhandling codehere
System.out.println (e.toString ());
}
System.out.print (mArray.toString ());
}
}MyArray.java
// other code above
publicclassIsFullException extends Exception {
    publicStringtoString (){
        return"MyArray isfull.";
    }
}
publicvoidadd(int d)throwsIsFullException {
                       /* v3 */
    if(isFull())thrownewIsFullException ();
data[size++] =d;
}
// other code below
â€¢Slowest of them all, not good for this situation.
â€¢A little too advance / too JAVA specific for this classDemonstration on isFull() (try â€“ catch)
12Recap 
â€¢Array is an array of data of the same type, referred to by a common 
name.
â€¢Array must be in a continuous memory for speed.
â€¢Array in JAVA is an object, stored in dynamic memory.
â€¢Random access  data on an array is ğ‘‚(1)
â€¢Adding data to an unordered array is ğ‘‚(1)
â€¢Later, more comprehensive add method 
13Method 
insert(int d, int idx)
â€¢Say, if we want to insert
6 at index 2
â€¢If order does not matter , consider 
the following operations
1.Move data[2] to the end of array
2.Put 6 at data[2]
3.Increate size by one 
â€¢Step 1. must be done before 
step 2, but step 3 can be 
done at anytime.publicvoidinsert(int d,intindex){
data[size++]=data[index];
data[index] =d;
}
â€¢Letâ€™s implement this.
â€¢What is the Big -O?
14Insertion (Ordered Array)
â€¢Right shift so that data[index] is available 
â€¢Remark : the supplied idx must not break the order 
of data in the array
â€¢Steps (To insert 6 in this ordered array)
â€¢Move everything >6 to the 
right one position.
â€¢Put 6 at the position
â€¢Increase size by 1
15publicvoidinsert(int d,intindex){
    for(int i=size;i>index; i--){
    data[i]=data[i-1];
}
data[index] =d;
size++;
}Big-O of Ordered Array Insertion
â€¢Best Case (a.k.a. lucky): insert at 
the end, ğ‘‚(1)
â€¢Worst Case: insert at the 
index 0, ğ‘‚(ğ‘›) 
â€¢Average Case: count everything 
and average  publicvoidinsert(int d,intindex){
    for(int i=size;i>index; i--){
    data[i]=data[i-1];
}
data[index] =d;
size++;
}
16â€¢For average case, Letâ€™s start counting
â€¢Insert at 0: n copy operations
â€¢Insert at 1: n -1 copy operations
â€¢Insert at 2: n -2 copy operations
â€¢â€¦
â€¢Insert at n -1: 1 copy operations
â€¢Insert at n: 0 copy operations
Note that the other operations are constants , 
not affecting the Big -O
â€¢Total operations are 
1+2+3+â‹¯+ğ‘›=ğ‘›(ğ‘›+1)
2
â€¢We insert n times (from 0 to n -1)
â€¢So, the average  is 
ğ‘›(ğ‘›+1)
2Ã·ğ‘›=(ğ‘›+1)
2âˆˆğ‘‚(ğ‘›)Overloaded insert(int d) on ordered array
â€¢Recall, insert(int d, int idx) applies to unordered 
array
â€¢insert(int d) is to insert into ordered array via 
computed index 
â€¢No need the index parameter because the index 
must be computed for consistency.
â€¢Same logic for add(int d) to ordered array 
â€¢Steps (insert 6 in this ordered array)
â€¢(Find where to insert and) Move everything > 6 
to the right one position.
â€¢Put 6 
at the 
position
â€¢Increase 
size by 1
17index = size â€“ 1; 
while (data[index] > d) {
    data[index+1] = data[index];
    index--;
}
data[++index] = d;
size++;Method find(int d)
â€¢In an unordered  array, best we can do is linear search
â€¢Big-O is similar to insertion of an ordered array.Simple implementation
publicintfind(int d){
intindex=-1;
for(int i=0;i<size;i++){
if(data[ i]==d){
index=i;
break;
}
}
returnindex;
}Compact version
publicintfind(int d){
for(int i=0;i<size;i++){
if(data[ i]==d){
return i;
}
}
return-1;
}Efficiency
Best Case:         ğ‘‚(1)
Worst Case:      ğ‘‚(ğ‘›) 
Average Case:  ğ‘‚(ğ‘›) 
18Method 
binarySearch(int d) on Ordered Array
â€¢Binary search  on ordered  array is by far faster than performing a 
linear search .
publicintbinarySearch (intd){
inta=0,b=size-1;
while(a<=b) {
intm=(a+b)/2;
if(data[m]==d) returnm;
if(d<data[m]) b=m-1;
elsea=m+1;//d>data[m]
}
return-1;
}
19Big-O of binary search
â€¢Best Case  is still O(1)
â€¢Worst Case: we need to count
â¢1st  iteration: ğ‘›
â¢2nd iteration: ğ‘›
2
â¢3rd: ğ‘›
4
â¢kth: ğ‘›
2ğ‘˜âˆ’1
â¢Last iteration: 1 
â€¢If we run k round, we stop at 
ğ‘›
2ğ‘˜âˆ’1=1 or ğ‘˜=log ğ‘›+1
â€¢So, the worst case  
is ğ‘˜ round or ğ‘‚(log(ğ‘›))Stop criteriaâ€¢For average case , Letâ€™s start 
counting
â€¢The search data is at index 
0,1,2,3,â€¦,ğ‘›âˆ’1, not found
â€¢We will sum the number of operations 
of all search and divide it by ğ‘›+1
â€¢There are [ ğ‘˜=log(ğ‘›+1)]:
â€¢1 data that need only 1 comparison
â€¢2 data that need 2 comparisons
â€¢4 data that need 3 comparisons
â€¢â€¦
â€¢2k-1 data that need k comparisons 
â€¢Total operations 
  = 1*20+2*21+3*22+4*23+..+k *2k-1
20Arkkkk ~~Sum 
 1*20    = 20        
+2*21     = 21   + 21
+3*22     = 22   + 22   +22
+4*23     = 23   + 23   +23   +23
+..     = â€¦ â€¦â€¦â€¦
+k*2k-1   = 2k-1 + 2k-1 +2k-1 +2k-1 +â€¦ +2k-1
        = 2k-1 + 2k-1-20 + 2k-1-20-21 + 2k-1-20-21-22 + â€¦ 
          + 2k-1-20-21-22-â€¦-2k-2
        = 2k-20 + 2k-21 + 2k-22 + 2k-23 + 2k-24 + â€¦ + 2k-2k-1
        = k2k-(20+21+21+21+â€¦+2k-1) 
        = k2k-(2k-1) = k2k â€“ 2k + 1
        = (k-1)2k+1
â€¢So, average = ğ‘˜âˆ’12ğ‘˜+1
ğ‘›+1 = ğ‘˜âˆ’12ğ‘˜+1
2ğ‘˜âˆ’1+1 Ïµ O(k) = O(log n)Formula
à·
ğ‘–=0ğ‘˜âˆ’1
2ğ‘–=2ğ‘˜âˆ’1
21Recap
â€¢Let summarize using a table
â€¢Now , only method delete left.Methods Best case Worst case Average case
Add (unordered) ğ‘‚(1) ğ‘‚(1) ğ‘‚(1)
Insert unordered array ğ‘‚(1) ğ‘‚(1) ğ‘‚(1)
Insert ordered array / add (ordered) ğ‘‚(1) ğ‘‚(ğ‘›) ğ‘‚(ğ‘›)
Find unordered array ğ‘‚(1) ğ‘‚(ğ‘›) ğ‘‚(ğ‘›)
Binary search ordered array ğ‘‚(1) ğ‘‚(logğ‘›) ğ‘‚(logğ‘›)
22Delete from an Unordered  Array 
delete(int index)
â€¢If order is not important, it can 
be done in ğ‘‚(1) time.
â€¢If we want to delete 7 at index=2
1.Copy last data to index 2
2.Decrease size by one
Note that the last element will be 
removed automatically.
â€¢Very simple to implement
Note that we skip the searching for data 
step since that would mean ğ‘‚(ğ‘›).publicvoiddelete(int index){
data[index] = data[ --size];
}
23Delete from an Ordered  Array 
delete(int index)
â€¢Very similar to insert into an 
ordered array.
â€¢Move everyone to the left, instead of 
the right
â€¢Steps from delete at index=2
â€¢Start from the index
â€¢Move data from the right to the current 
place
â€¢Keep going to the right and do the 
same thing until the end
â€¢Decrease size by 1
â€¢Big-O is similar to insert into an 
ordered array.
â€¢Letâ€™s implement this.
publicvoiddelete(int index){
    for(int i=index; i<size-1;i++){
    data[i]=data[i+1];
}
size--;
}
240 0 0 0 0Limitation of Array
â€¢Given the shaded areas are occupied .
â€¢It is not possible to 
â€¢create an array of size 10.
â€¢Although we have more than
enough memory.
var addr
b 0b
25Expanding Array (add())
â€¢Array data structures can not be 
expanded. 
â€¢What we can do is 
â€¢Create a bigger array
â€¢Copy all data to the new one
â€¢Point to the new one
â€¢Delete the old one
â€¢Modified add(); 
â€¢Seems too be slow, right?â€¢Two versions of expands() 
voidexpands() { // version A
MAX_SIZE =MAX_SIZE+M;
intnewData[]=newint[MAX_SIZE];
System.arraycopy (data,0,newData,0,size);
data=newData;
System.gc ();
}
voidexpands() { // version B
MAX_SIZE =2*MAX_SIZE;
intnewData[]=newint[MAX_SIZE];
System.arraycopy (data,0,newData,0,size);
data=newData;
System.gc ();
}For sufficiently large M such as M=1000
publicvoidadd(int d){
if(isFull())expands();
data[size++] =d;
}
26The Big -O
â€¢For expand() , Big -O is always ğ‘‚(ğ‘›)
â€¢For add()
â€¢Best case is ğ‘‚(1), we do not have to expand.
â€¢Worst case is ğ‘‚(ğ‘›), we must expand and copy ğ‘› times.
â€¢Let compute for the average case for both version.
27Version A
MAX_SIZE =MAX_SIZE+M;
â€¢To compute average, we assume that data are added ğ‘› times
â€¢Add data from index 0 to S -1 take S operations
â€¢Add data at index S takes S+1 operations, since we need to copy and add a new data.
â€¢Add data from index S+1 to S+M -1 take M-1 operations
â€¢Add data at index S+M takes S+M+1 operations
â€¢And so on ..
â€¢Total operation is
ğ‘†+ğ‘˜(ğ‘†+1)+ğ‘˜(ğ‘€âˆ’1)+[ğ‘€+2ğ‘€+3ğ‘€+â‹¯+(ğ‘˜âˆ’1)ğ‘€]
=(ğ‘˜+1)ğ‘†+ğ‘˜ğ‘€+ğ‘˜âˆ’1ğ‘˜
2ğ‘€â€¦S M M M MExpands k times
S
S+1M-1 M-1 M-1 M-1
S+M+1 S+2M+1 S+(k-1)M+1
ğ‘›=ğ‘†+ğ‘˜ğ‘€
ğ‘˜=ğ‘›âˆ’ğ‘†
ğ‘€
28Average of Version A
â€¢Total Operations 
ğ‘†ğ‘¢ğ‘š =ğ‘˜+1ğ‘†+ğ‘˜ğ‘€ +ğ‘˜âˆ’1ğ‘˜
2ğ‘€
ğ‘†ğ‘¢ğ‘š =ğ‘›âˆ’ğ‘†
ğ‘€+1ğ‘†+ğ‘›âˆ’ğ‘†
ğ‘€ğ‘€+ğ‘›âˆ’ğ‘†
ğ‘€âˆ’1ğ‘›âˆ’ğ‘†
ğ‘€
2ğ‘€
ğ‘†ğ‘¢ğ‘š =ğ‘›âˆ’ğ‘†+ğ‘€
ğ‘€ğ‘†+ğ‘›âˆ’ğ‘†+ğ‘›âˆ’ğ‘†âˆ’ğ‘€(ğ‘›âˆ’ğ‘†)
2ğ‘€
â€¢Without simplifying it further, we can see that it is ğ‘‚(ğ‘›2)
â€¢Since average is ğ‘†ğ‘¢ğ‘š
ğ‘›, so, the average is ğ‘‚(ğ‘›).ğ‘›=ğ‘†+ğ‘˜ğ‘€
ğ‘˜=ğ‘›âˆ’ğ‘†
ğ‘€
29Version B
MAX_SIZE =2*MAX_SIZE;
â€¢First, let compute relationship between n and k
ğ‘›=ğ‘†+ğ‘†+2ğ‘†+4ğ‘†+..+2ğ‘˜âˆ’1ğ‘†
ğ‘›=1+1+2+4+..+2ğ‘˜âˆ’1ğ‘†
ğ‘›=2ğ‘˜ğ‘†
ğ‘˜=logğ‘›
ğ‘†
â€¢Let compute average in the next slide
   S S 2S
â€¦4SExpands k times
2k-1S
30Version B
MAX_SIZE =2*MAX_SIZE;
â€¢Again, we assume we add data n times
â€¢Add data from index 0 to S -1 take S operations
â€¢Add data at index S takes S+1 operations, from copy and add new data
â€¢Add data from index S+1 to 2S -1 take S -1 operations
â€¢Add data at index 2S takes 2S+1 operations
â€¢And so on..
â€¢The total operations is 
ğ‘†+2ğ‘†+4ğ‘†+8ğ‘†+..+2ğ‘˜ğ‘†=(2ğ‘˜+1âˆ’1)ğ‘†=2(2ğ‘˜ğ‘†)âˆ’ğ‘†=2ğ‘›âˆ’ğ‘†
â€¢So, average is 2ğ‘›âˆ’ğ‘†
ğ‘›âˆˆğ‘‚1!S S 2S
â€¦4SExpands k times
2k-1Sğ‘›=2ğ‘˜ğ‘†
ğ‘˜=logğ‘›
ğ‘†
S S-1 2S-1 4S-1 2k-1S-1
S+1 2S+1 4S+1 2k-1S+1
31Example challenge
public class Solution {
 public int removeDuplicates( int[] nums ) {
   return 0;    
 }
} 
/* it is already sorted. Care to swap the first 
next value to its correct position? */
32
Example challengevoid sortColors( int[] nums) {     
 int tmp, low = 0, mid = 0, high = nums.length - 1;
 while (mid <= high) {
  if (nums[mid] == 0) {
   // Swap arr[low] and arr[mid], move both forward
   tmp = nums[low];
   nums[low] = nums[mid];
   nums[mid] = tmp;
   /* use below technique leads to unexpected side effect 
     (accessing same index nums[index] both LHS and RHS)
   // nums[low] = nums[low] + nums[mid];
   // nums[mid] = nums[low] - nums[mid];
   // nums[low] = nums[low] - nums[mid];      */
   low++;
   mid++;        
  } else if (nums[mid] == 1) {
   mid++;
  } else {
   tmp = nums[mid];
   nums[mid] = nums[high];
   nums[high] = tmp;
   // if the same variable is modified in -place incorrectly, 
   // we may accidentally cause corruption,
   // Swap arr[mid] and arr[high], move high backward
   // nums[mid] = nums[mid] + nums[high];
   // nums[high] = nums[mid] - nums[high];
    // nums[mid] = nums[mid] - nums[high];
   high--;
  } 
 }
}33
Summary
â€¢Let summarize all methods of array data structures
Methods Best case Worst case Average case
Add into an array ğ‘‚(1) ğ‘‚(1) ğ‘‚(1)
Insert into an unordered array ğ‘‚(1) ğ‘‚(1) ğ‘‚(1)
Insert / Add into an ordered array ğ‘‚(1) ğ‘‚(ğ‘›) ğ‘‚(ğ‘›)
Find in an unordered array ğ‘‚(1) ğ‘‚(ğ‘›) ğ‘‚(ğ‘›)
Binary search in an ordered array ğ‘‚(1) ğ‘‚(logğ‘›) ğ‘‚(logğ‘›)
Delete from an unordered array ğ‘‚(1) ğ‘‚(1) ğ‘‚(1)
Delete from an ordered array ğ‘‚(1) ğ‘‚(ğ‘›) ğ‘‚(ğ‘›)
Expand an array ğ‘‚(n) ğ‘‚(ğ‘›) ğ‘‚(ğ‘›)
Add with expand ğ‘‚(1) ğ‘‚(ğ‘›) ğ‘‚(1)version B
an example of amortized analysis
34