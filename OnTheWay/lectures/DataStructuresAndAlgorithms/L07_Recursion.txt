Recursion
(kmitl) cs -departmentCh.07Outline
â€¢Fundamental Idea 
â€¢Introduction
â€¢Recursive Solution
â€¢Example
â€¢Factorial  
â€¢Fibonacci Sequence 
â€¢Analysis of recurrence relations running time 
â€¢What is divide and conquer strategy 
â€¢(Back to more) Recursion
â€¢Tail Recursion  
â€¢Memoization 
â€¢Dynamic Programming 
2Introduction Recursion
â€¢An extremely powerful problem -solving method
â€¢Break a problem into smaller identical  problems
â€¢An alternative to iteration (a.k.a. loop)
3Recursive Solution
â€¢Facts about a recursion solution 
â€¢A recursive method calls itself
â€¢Each recursive call solves an identical, but smaller problem
â€¢Stop at base case  where the solution is known 
â€¢Thus, there must be a base case or base cases.
â€¢Example
â€¢Sequential search
â€¢Start at the beginning of the collection
â€¢When an item is removed, the rest  of the collection become a new 
problem.
â€¢Binary search
â€¢Repeatedly halves the search space.
â€¢The remaining  half become a new problem.
4Recursive Solution
Four questions for construction recursive solutions
â€¢How can we define the problem in terms of a smaller problem of 
the same type?
â€¢How does each recursive call diminish the size of the problem?
â€¢What are the base cases?
â€¢Is the diminishing -size problem reaching the base cases?
5Iterative vs recursion: Factorial (trivial) 
6
https://www.slideshare.net/alhazmy13/data -structures -part5 -recursion  
https://www.pinterest.com/pin/121737996155827145/  https://o.quizlet.com/
e8Wf27COw4tT7Pkt -VZXUQ.png   Factorial
â€¢Problem 
â€¢Compute the factorial of an integer n
â€¢Definition
â€¢factorial(n) = n*(n -1)*(n -2)*..*1 , 
for any integer n>0
â€¢factorial(0) = 1
â€¢Recursive definition
â€¢factorial(n) = n * factorial(n -1)
â€¢factorial(0) = 1
â€¢These are the same 
â€¢factorial(n) = n * [(n -1)*(n -2)*..*1]
      = n * factorial(n)
â€¢factorial(0) = 1â€¢Java Implementation
int factorial(int n) {
  int r = 1;
  while(n>0) {
    r = r*n;
    n--;
  }
  return r;
}
int factorial(int n) {
  if(n==0) return 1;
  return n*factorial(n -1);
}
7Calling factorial(3)
int factorial( 3) {
  if(3==0) return 1;
  return 3*factorial( 3-1);
}
int factorial( 2) {
  if(2==0) return 1;
  return 2*factorial( 2-1);
}
int factorial( 1) {
  if(1==0) return 1;
  return 1*factorial( 1-1);
}
int factorial( 0) {
  if(0==0) return 1;
  return 0*factorial(0 -1);
}int factorial(3) {
  if(3==0) return 1;
  return 3* factorial(3 -1);
}
int factorial(2) {
  if(2==0) return 1;
  return 2* factorial(2 -1);
}
int factorial(1) {
  if(1==0) return 1;
  return 1* factorial(1 -1);
}
Time = O(n)
Memory = O(n)Popped from 
a stack
8Fibonacci Sequence
â€¢The setup
â€¢We are to count how many 
magic rabbit at the end of 
each month.
â€¢A magic rabbit takes one 
month to become adult (be 
able to reproduce).
â€¢Every adult magic rabbit 
produce one magic rabbit 
every month. (gives an 
offspring next month â€¦magic!)
â€¢Rabbits never die.Month Young rabbit Adult rabbit Total
0 1 0 1
1 0 1 1
2 1 1 2
3 1 2 3
4 2 3 5
5 3 5 8
6 5 8 13
â€¦
n f(n-2) f(n-1) f(n-2)+f(n -1)
9Fibonacci Sequence: Recurrent Relation
â€¢fibonacci(n) = fibonacci(n -1) + fibonacci(n -2)
â€¢fibonacci(0) = 1
â€¢fibonacci(1) = 1
â€¢Java Implementation
int fibo(int n) {
  if((n==0)||(n==1) return 1;
  return fibo(n-1)+fibo(n-2);
}
10Calling fibo(5)
fibo(5)   
fibo(4)   
fibo(3)   
fibo(1)   fibo(2)   
fibo(0)   fibo(2)   fibo(1)   
fibo(1)   fibo(0)   fibo(3)   
fibo(2)   fibo(1)   
fibo(1)   fibo(0)   
11Fibonacci Sequence: Discussion
â€¢Example of multiple recursion
â€¢Recursion call happens more than one 
in the method
â€¢This implementation is a bad style recursion
â€¢We must solve the same sub -problem multiple times .
â€¢You can redesign the algorithm, or you can use dynamic programming to 
make it faster.int fibo(int n) {
  if((n==0)||(n==1) return 1;
  return fibo(n-1)+fibo(n-2);
}
12Algorithm Paradigm
â€¢Brute Force
â€¢Divide and Conquer , Decrease and Conquer 
â€¢Transform and Conquer 
â€¢Dynamic Programming
â€¢Greedy Algorithm
â€¢Backtracking and Branch -and-Bound 
â€¢(Learning Algorithm e.g. reinforcement learning)
13Analyzing running time with recurrence 
relations
â€¢What is the order of growth of the time 
required by times1 as a function of n, 
where n is the magnitude of the 
parameter b. 
â€¢This recurrence relation states that the time to multiply a by b (of size 
n > 0) is the time required to call times1 of value a by (a number of 
size n â€“ 1 as) b. plus a constant amount of work (the primitive 
operations performed).int times1(int a, int b) {
  if((b==0) return 0;
  return a + times1(a, b -1);
}
14T(n) = T(n â€“ 1) + c1    ;for n > 0 
T(0) = c2 
https://www.cs.cornell.edu/courses/cs3110/2009sp/lectures/lec19.html  Analyzing running time with recurrence 
relations
â€¢Expanding the recurrenceint times1(int a, int b) {
  if((b==0) return 0;
  return a + times1(a, b -1);
}
15T(n) = T(n â€“ 1) + c1    ;for n > 0 
T(0) = c2 
T(n) = T(n â€“ 1) + c1    ;for n > 0 
     = (T(n â€“ 2) + c1) + c1 
     = T(n â€“ 3) + c1 + c1 + c1
     â€¦
     = T(n â€“ k) + k*c1 
     â€¦
     = T(0) + n*c1 
     = c2 + n * c1 
Hence
O(n)   Analyzing running time with recurrence 
relations
â€¢Expanding the recurrenceint times2(int a, int b) {
  if((b==0) 
    return 0; 
  else if (b % 2 == 0) 
    return time2(a * 2, b / 2);
  return a + times2(a, b -1);
}
16T(n) = T(n â€“ 1) + c1    ;for n > 0 & odd n 
T(n) = T(n/2) + c2     ;for n > 0 & even n
T(0) = c3 
T(2m) = T(2m â€“ 1) + c2    ;for m > 0 
     = (T(2m â€“ 2) + c2) + c2 
     â€¦
     = T(2m â€“ m) + m*c2   ; T(1) + m * c2
     = (T(0) + c1) + m * c2
     = c3 + c1 + m * c2 
       // note that full analysis should 
       // consider b * c1
       // but b is also bounded by m 
       // note that if n is odd, 
       // add another c1
Hence
O(log n)  Analyzing running time with recurrence 
relations visualized in Recursion tree
â€¢Consider 
      T(n) = 2T(n/2) + n2 
17
https://www.cs.cornell.edu/courses/cs3110/2012sp/lectures/lec20 -master/lec20.html  Analyzing running time with recurrence 
relations, visualized in Recursion tree  and 
Master Theorem
â€¢(Cookbook ) the time 
complexity of a recursive 
relation is given by
ğ‘‡ğ‘›=ğ‘ ğ‘‡ àµ—ğ‘›ğ‘+ğ‘‚ğ‘›ğ‘‘ 
a ğ‘“ğ‘œğ‘Ÿ ğ‘>0,ğ‘>1,ğ‘‘ â‰¥0 ğ‘¡â„ğ‘’ğ‘›  
ğ‘‡ğ‘›
=ğ‘‚ğ‘›ğ‘‘ ğ‘–ğ‘“ ğ‘‘ > log ğ‘ğ‘ 
ğ‘‚ğ‘›ğ‘‘ğ‘™ğ‘œğ‘” ğ‘› ğ‘–ğ‘“ ğ‘‘=log ğ‘ğ‘
ğ‘‚ğ‘›log ğ‘ğ‘ ğ‘–ğ‘“ ğ‘‘ <log ğ‘ğ‘
18â€¢(Official ) Consider the recurrence   
ğ‘‡ğ‘›=ğ‘ ğ‘‡Î¤ğ‘›ğ‘+ğ‘“ğ‘› ; a ğ‘,ğ‘ ğ‘ğ‘Ÿğ‘’ ğ‘ğ‘œğ‘›ğ‘ ğ‘¡ğ‘ğ‘›ğ‘¡ğ‘   
 ( ğ‘›=ğ‘ ğ‘–ğ‘§ğ‘’  ğ‘œğ‘“ ğ‘–ğ‘›ğ‘ğ‘¢ğ‘¡ , 
 ğ‘= ğ‘›ğ‘¢ğ‘šğ‘ğ‘’ğ‘Ÿ  ğ‘œğ‘“ ğ‘ ğ‘¢ğ‘ğ‘ğ‘Ÿğ‘œğ‘ğ‘™ğ‘’ğ‘šğ‘   ğ‘–ğ‘› ğ‘¡â„ğ‘’ ğ‘Ÿğ‘’ğ‘ğ‘¢ğ‘Ÿğ‘ ğ‘–ğ‘œğ‘›
 Î¤ğ‘› ğ‘= ğ‘ ğ‘–ğ‘§ğ‘’  ğ‘œğ‘“ ğ‘’ğ‘ğ‘â„  ğ‘ ğ‘¢ğ‘ğ‘ğ‘Ÿğ‘œğ‘ğ‘™ğ‘’ğ‘š  ) 
ğ‘ğ‘ğ‘ ğ‘’1  ğ‘–ğ‘“ ğ‘“ğ‘›=ğ‘‚ğ‘›log ğ‘ğ‘âˆ’ğœ€ a ğ‘“ğ‘œğ‘Ÿ ğ‘ ğ‘œğ‘šğ‘’  ğ‘ğ‘œğ‘›ğ‘ ğ‘¡ğ‘ğ‘›ğ‘¡  ğœ€>0
 ğ‘¡â„ğ‘’ğ‘›  ğ‘‡ğ‘›=ğ‘‚(ğ‘›log ğ‘ğ‘)
ğ‘ğ‘ğ‘ ğ‘’2  ğ‘–ğ‘“ ğ‘“ğ‘›= Î˜ğ‘›log ğ‘ğ‘
 ğ‘¡â„ğ‘’ğ‘›  ğ‘‡ğ‘›=Î˜(ğ‘›log ğ‘ğ‘logğ‘›) 
ğ‘ğ‘ğ‘ ğ‘’3  ğ‘–ğ‘“ ğ‘“ğ‘›=Î©ğ‘›log ğ‘ğ‘+ğœ€
 ğ‘“ğ‘œğ‘Ÿ ğ‘ ğ‘œğ‘šğ‘’  ğ‘ğ‘œğ‘›ğ‘ ğ‘¡ğ‘ğ‘›ğ‘¡  ğœ€>0,ğ‘ğ‘›ğ‘‘  
 ğ‘–ğ‘“ ğ‘“ ğ‘ ğ‘ğ‘¡ğ‘–ğ‘ ğ‘“ğ‘–ğ‘’ğ‘   ğ‘¡â„ğ‘’ ğ‘ ğ‘šğ‘œğ‘œğ‘¡â„ğ‘›ğ‘’ğ‘ ğ‘   ğ‘ğ‘œğ‘›ğ‘‘ğ‘–ğ‘¡ğ‘–ğ‘œğ‘›  ğ‘ğ‘“ğ‘›
ğ‘â‰¤ğ‘ğ‘“ğ‘›
 ğ‘“ğ‘œğ‘Ÿ ğ‘ ğ‘œğ‘šğ‘’  ğ‘ğ‘œğ‘›ğ‘ ğ‘¡ğ‘ğ‘›ğ‘¡  ğ‘ <1
ğ‘¡â„ğ‘’ğ‘›  ğ‘‡ğ‘›=Î˜(ğ‘“ğ‘›)
 Analyzing running time with recurrence 
relations (Recursion tree and Master Method )
â€¢T(n) = aT(n/b) + f(n) (We can visualize this as a recurrence tree, where)  
â€¢the nodes in the tree have a 
branching factor of a. The top 
node has work f(n) associated 
with it, 
â€¢the next level has work f(n/b) 
associated with each of a 
nodes, the next level has work f(n/b2) associated with each of a2 nodes, and so on. 
â€¢At the leaves are the base case corresponding to some 1 â‰¤ n < b. The tree has logbn 
levels, so the total number of leaves is alog
bn = nlog
ba. 
â€¢(In addition) The total time taken is just the sum of the time taken at each level. The 
time taken at the i -th level is aif(n/bi), and the total time is the sum of this quantity 
as i ranges from 0 to logbnâˆ’1, plus the time taken at the leaves which is O(nlog
ba) 
â€¢Thus ğ‘‡ğ‘›= Ïƒğ‘–=ğ‘œğ‘–=log ğ‘ğ‘ğ‘ğ‘–ğ‘“(Î¤ğ‘›
ğ‘ğ‘–)+ğ‘‚(ğ‘›log ğ‘ğ‘) 
19
Analyzing running time with recurrence 
relations (Recursion tree and Master Method )
â€¢T(n) = aT(n/b) + f(n)
â€¢ğ‘‡ğ‘›= Ïƒğ‘–=ğ‘œğ‘–=log ğ‘ğ‘ğ‘ğ‘–ğ‘“(Î¤ğ‘›
ğ‘ğ‘–)+ğ‘‚(ğ‘›log ğ‘ğ‘)
â€¢i.e. What this sum looks like depends on how the asymptotic growth of f(n) compares to the 
asymptotic growth of the number of leaves. There are three cases:
1. f(n) is ğ‘‚(ğ‘›log ğ‘ğ‘ âˆ’ ğœ–) 
â€¢Since the leaves grow faster than f, asymptotically all of the work is done at the leaves, so 
T(n) is ğœƒ(ğ‘›log ğ‘ğ‘ ). 
2. f(n) is ğ‘‚(ğ‘›log ğ‘ğ‘ ) 
â€¢The leaves grow at the same rate as f with the tree depth of O(log n) levels. 
This yields T(n) is ğœƒ(ğ‘›log ğ‘ğ‘ logğ‘›). 
3. f(n) is ğ‘‚(ğ‘›log ğ‘ğ‘+ ğœ–) 
â€¢Since f grow faster than the number of leaves, The asymptotic total amount of work is 
dominated by the work done at the root. T(n) is ğœƒ(ğ‘“(ğ‘›)). 
20Recurrence Relation
Recursion Tree Method: Master Method 
1. If f(n) = ğ‘‚(ğ‘›logğ‘ğ‘âˆ’ğœ€) for some constant ğœ€ > 0 then ğ‘‡ğ‘›= ğœƒğ‘›logğ‘ğ‘
2. If f(n) = ğœƒğ‘›logğ‘ğ‘ then ğ‘‡ğ‘›= ğœƒğ‘›logğ‘ğ‘ ğ‘™ğ‘œğ‘”ğ‘›  
3. If f(n) = Î©(ğ‘›logğ‘ğ‘+ğœ€) for some constant ğœ€ > 0, 
                                           and if af(n/b) <= cf(n) for some constant c < 1 
        and all sufficiently large n, then ğ‘‡ğ‘›= ğœƒğ‘“(ğ‘›) 
T(n) = 4T(n/2) + Î˜(n)
a = 4, b = 2 â‡’ log_b a = logâ‚‚4 = 2
f(n) = Î˜(n) 
Since f(n) = O(n^{ 2 - Îµ}) for Îµ = 1,  // or cookbook f(n) < O(n2) 
this fits Case 1  of the Master Theorem.     
T(n)=Î˜(n2) 
21https://youtu.be/YjrcREdUD9g?si=wmvpL0AFdEyTqfzR  Recurrence Relation
Recursion Tree Method: Master Method 
1. If f(n) = ğ‘‚(ğ‘›logğ‘ğ‘âˆ’ğœ€) for some constant ğœ€ > 0 then ğ‘‡ğ‘›= ğœƒğ‘›logğ‘ğ‘
2. If f(n) = ğœƒğ‘›logğ‘ğ‘ then ğ‘‡ğ‘›= ğœƒğ‘›logğ‘ğ‘ ğ‘™ğ‘œğ‘”ğ‘›  
3. If f(n) = Î©(ğ‘›logğ‘ğ‘+ğœ€) for some constant ğœ€ > 0, 
                                           and if af(n/b) <= cf(n) for some constant c < 1 
        and all sufficiently large n, then ğ‘‡ğ‘›= ğœƒğ‘“(ğ‘›) 
T(n) = 9T(n/3) + Î¸(n2) 
a = 9, b = 3 â‡’ log_b a = log39 = 2
f(n) = Î˜(n2) = Î˜(n^{log_b a})
Since f(n) = O(n^{ 2}) // f(n)= Î˜(nlogb â€‹a â‹… log_k n) for some ğ‘˜â‰¥0, then:
this fits Case 2  of the Master Theorem.
T(n) = Î¸(n2 log n)  
    
22Recurrence Relation
Recursion Tree Method: Master Method 
1. If f(n) = ğ‘‚(ğ‘›logğ‘ğ‘âˆ’ğœ€) for some constant ğœ€ > 0 then ğ‘‡ğ‘›= ğœƒğ‘›logğ‘ğ‘
2. If f(n) = ğœƒğ‘›logğ‘ğ‘ then ğ‘‡ğ‘›= ğœƒğ‘›logğ‘ğ‘ ğ‘™ğ‘œğ‘”ğ‘›  
3. If f(n) = Î©(ğ‘›logğ‘ğ‘+ğœ€) for some constant ğœ€ > 0, 
                                           and if af(n/b) <= cf(n) for some constant c < 1 
        and all sufficiently large n, then ğ‘‡ğ‘›= ğœƒğ‘“(ğ‘›) 
T(n) = 2T(n/2) + Î¸(n2) 
a = 2, b = 2 â‡’ log_b a = log22 = 1
f(n) = Î˜(n2)   // > O(nlog_b a ) 
Since f(n)=Î˜(n^2)=Î©(n^{1+Îµ}) forÎµ=1 
this fits Case 3  of the Master Theorem.
T(n)=Î˜(n2)
23Recurrence Relation
Recursion Tree Method: Master Method 
1. If f(n) = ğ‘‚(ğ‘›logğ‘ğ‘âˆ’ğœ€) for some constant ğœ€ > 0 then ğ‘‡ğ‘›= ğœƒğ‘›logğ‘ğ‘
2. If f(n) = ğœƒğ‘›logğ‘ğ‘ then ğ‘‡ğ‘›= ğœƒğ‘›logğ‘ğ‘ ğ‘™ğ‘œğ‘”ğ‘›  
3. If f(n) = Î©(ğ‘›logğ‘ğ‘+ğœ€) for some constant ğœ€ > 0, 
                                           and if af(n/b) <= cf(n) for some constant c < 1 
        and all sufficiently large n, then ğ‘‡ğ‘›= ğœƒğ‘“(ğ‘›) 
T(n) = 4T(n/2) + n3
 a = 4, b = 2, and f(n) = n3 â†’ logba = log24 = 2 
 f(n) = Î©ğ‘›log24+ğœ€= Î©(ğ‘›2+ğœ€) // f(n) = Î©(n3) with ğœ€ = 1 ... ( case 3 )
Hence
 T(n) = ğœƒ(n3) 
Proof of there exists such c (and n0) 
 af(n/b) = 4(n/2)3 = n3/2 <= cf(fn) for c = Â½ and n >= n0  24Remark  (Analyzing running time with 
recurrence relations)
â€¢Not a proof 
â€¢Easiest â†’ Master Theorem
â€¢Alternatively 
â€¢Recursion Tree
â€¢Iteration Method 
â€¢Substitution method 
25Remark  (Analyzing running time with 
recurrence relations)
â€¢Solve the recurrence 
using iteration method:
â€¢T(n) = 2T(n/2) + n / log n
T(1) = Î˜(1)  
â€¢Steps 
â€¢At level i:
â€¢- 2^i calls to T(n/2^i)
â€¢- Each contributes:  n / 
(log(n/2^i))
26L0: T(n) = 2T(n/2) + n / log n
L1: = 4T(n/4) + 2(n/2)/log(n/2) + n/log n
L2: = 8T(n/8) + 4(n/4)/log(n/4) + ... 
...
Ti= (2^i) ( ((n/(2^i)) / (log(n/(2^i))) )
= n / (log(n/(2^i))  
Sum over all levels:
T(n) = Î£ n / log(n/2^i) 
= Î£ n / ( log(n) / log(2 ^i) )  â‰ˆ n * log log n 
= n Î£ 1 / ( log(n) â€“i) )
T(n) = Î˜(n log log n)
Outline
â€¢Fundamental Idea 
â€¢Introduction
â€¢Recursive Solution
â€¢Example
â€¢Factorial  
â€¢Fibonacci Sequence 
â€¢Analysis of recurrence relations running time 
â€¢What is divide and conquer strategy 
â€¢(Back to more) Recursion
â€¢Tail Recursion  
â€¢Memoization 
â€¢Dynamic Programming 
27Single/Multiple Recursion
â€¢Referred to how many times a method call itself within the 
method
â€¢Factorial is an example of single recursion while Fibonacci is the 
multiple one.
â€¢Factorial is a special kind of 
recursion called tail recursion ,
where the recursive call is at the 
very end of method.
â€¢All recursion can be rewrite using loop(s) and stack(s).
â€¢Tail recursion can be rewrite without stack.void factorial(int n) {
  if(n==0) return 1;
  return n*factorial(n -1);
}
28Memoization
â€¢Memoization ensures that a 
method doesn't run for the 
same inputs more than once 
by keeping a record of the 
results for the given inputs 
(usually in a hash map).int fibo(int n) {
  if (n <= 1) 
    return 1;
  return fibo(n -1) + fibo(n -2);
} 
29// []mem is accessible through out the 
// computation
int fibMem(int n, int[] mem) {
if (n <= 1)
return 1;
if (mem[n] != 0)
return mem[n];
mem[n] = fibMem(n -1,mem) + fibMem(n -2,mem);
return mem[n];
}
https://youtu.be/Qk0zUZW -U_M?si=_XXs3Q14pKs7eHOr  (improving recursion)  Dynamic Programming 
â€¢DP is a strategy  for optimization.
â€¢Building solution by expanding the known optimal  sub 
solution. 
â€¢One could, however, simulate recursion behavior for count ing 
ways in combinatoric space.
30Dynamic Programming Remark 
â€¢the key difference between DP and memoization. 
https://cs.stackexchange.com/questions/99513/dynamic -programming -vs-
memoization#:~:text=In%20summary%2C%20here%20are%20the,computation%20on%20the%20same%20problems .   
â€¢Memoization is a technique to avoid repeated computation on the same problems. It is 
special form of caching that caches the values of a function based on its parameters. 
â€¢memoization uses extra space (memory) to improve run time and is not effective  when the 
function does not have overlapping subproblems or when the inputs change frequently.
â€¢DP is a solution strategy which asks you to find similar smaller subproblems so as to 
solve big subproblems. It usually includes recurrence relations and memoization. 
â€¢In a sense, there could be a cache missed in memorization while there is no cache 
miss in dynamic programming
31Bottom -Up DP: Fibonacci 
32int fibo_dp(int n) {
 int [] cache = new int [n + 1];
 cache[0] = 0; // base case
 cache[1] = 1; // base case
 // if (n < 2)
 //   return cache[n];
 for (int i = 2; i <= n; i++) {
   cache[i] = cache[i -2] + cache[i -1];
 }
 return cache[n];
}int fibo_dp_space_o_one(int n) {
 int n_2 = 0;
 int n_1 = 1;
 int i = 2;
 int my_fib = 0;
 while (i <= n) {
   my_fib = n_2 + n_1;
   n_2 = n_1;
   n_1 = my_fib;
   i++;
 }
 return my_fib;
}Minimum Sum Sub Array
â€¢given an array of n integers. 
The task is to find the sum 
of the subarray which has 
the smallest possible sum.
â€¢input:    [ -4, 3, -1, -6, 8]
â€¢output: -8
33int min_sum_sub_arr_bf(int [] arr) {
int min_sum = Integer.MAX_VALUE;
for (int i = 0; i < arr.length -1; i++) {
int i_sum = 0;
for (int j = i; j < arr.length; j++) {
i_sum += arr[j];          
if (i_sum < min_sum) {
min_sum = i_sum;
}
}  
}
return min_sum;
}Minimum Sum Sub Array
34int min_sum_sub_arr_dp(int [] arr) { 
int [] cache = new int[arr.length]; 
// base case is inclusive
cache[0] = arr[0];
int min_sum = cache[0];
for (int i = 1; i < arr.length; i++) {
cache[i] = cache[i -1] + arr[i];
if (cache[i -1] + arr[i] > arr[i])
cache[i] = arr[i];  
// reset the start value
if (cache[i] < min_sum)
min_sum = cache[i];
}
return min_sum;    
}int mssa_dp_space_o_one(int [] arr) { 
//       20, -7, -3,  9,  4,  6, -9, 10
// accum 20, -7,-10, -1,  3, *6,* -9, 1 
int min_sum = arr[0];   
int accum = arr[0];
for (int i = 1; i < arr.length; i++) {
accum = accum + arr[i];
if (accum > arr[i]) 
accum = arr[i];
if (accum < min_sum) 
min_sum = accum;
//System.out.print(accum + " ");
} System.out.println();
return min_sum;
}private static intnumberOfPaths_recurse ( int m, 
                          int n, int [][] matrix) { 
           // matrix content is no need for this problem
 // Returns count of possible paths to reach
 // cell at row number (m - 1) and column number (n - 1) 
 // from the topmost leftmost cell (cell at 0, 0)
    
 if (m == 0 || n == 0) 
   return 1;
    
 returnnumberOfPaths_recurse (m - 1, n, matrix)
         + numberOfPaths_recurse (m, n - 1,matrix);
 // If diagonal movements are allowed 
  // then + numberOfPaths_recurse(matrix, m - 1, n - 1)
}
Number of Unique Paths
35https://tutorialhorizon.com/algorithms/dynamic -programming -
count -all-paths -from -top-left-to-bottom -right -of-a-mxn -matrix/  Number of Unique Paths
36staticvoidnumberOfPaths_cache_bottom_up( intr, intc /*, map matrix not need */ ) {
introws = 3, cols = 7;
int[][] cache = newint[rows][cols];  
                     
numberOfPaths_cache_sub( 0, 0, cache);
System.out.println(cache[ 0][0]);
}
staticintnumberOfPaths_cache_sub( intr, intc, int[][] cache) {
if(r >= cache.length || c >= cache[ 0].length)          return0;
if(r == cache.length -1|| c == cache[ 0].length -1return1; 
if(cache[r][c] > 0)
returncache[r][c];
cache[r][c] = numberOfPaths_cache_sub(r+ 1,c,cache)  
+ numberOfPaths_cache_sub(r, c+ 1, cache) ;
returncache[r][c];
}Number of Unique Paths
37static int numberOfPaths_DP( int m, int n) { 
 // begin preparation
 int [][] working_table = new int[m][n];
 for (int r = 0; r < m; r++)
   working_table[r][n -1] = 1;
 for (int c = 0; c < n; c++)
   working_table[m -1][c] = 1;
 // end preparation
 for (int row = m - 2; row >= 0; row--) {
   for (int col = n - 2; col >= 0; col--)
    working_table[row][col] = working_table[row+ 1][col] 
                                  + working_table[row][col+ 1];
 }
 // for (int [] row : working_table)
 //   System.out.println(Arrays.toString(row));
 return working_table[ 0][0];
}
m = 2 n = 2
recurse   | 2 (number of calls = 3)
memoiz  | 2 (number of calls = 1)
DP           | 2
-----
m = 2 n = 3
recurse   | 3 (number of calls = 5)
memoiz  | 3 (number of calls = 2)
DP           | 3
-----
m = 4 n = 4
recurse   | 20 (number of calls = 
39)
memoiz  | 20 (number of calls = 9)
DP           | 20Example challengepublic void floodFill( int[][] image, int sr, int sc, 
                                          int newColor) {
  int targetColor = image[sr][sc];
  if (targetColor == newColor) return;
  dfs(image, sr, sc, targetColor, newColor);
}
private void dfs(int[][] image, int r, int c, 
                         int targetColor, int newColor) {
  // Check boundaries
  if (r < 0 || r >= image.length 
              || c < 0 || c >= image[ 0].length) return;
  // Stop if the current pixel is not the target color
  if (image[r][c] != targetColor) return;
  // Change the color
  image[r][c] = newColor;
  // Visit neighbors (4 -directional)
  dfs(image, r + 1, c, targetColor, newColor);
  dfs(image, r - 1, c, targetColor, newColor);
  dfs(image, r, c + 1, targetColor, newColor);
  dfs(image, r, c - 1, targetColor, newColor);
}38Flood Fill Algorithm
Given a 2D grid (image), a starting cell (sr, 
sc), a target color, and a new color, 
replace all 4 -directionally connected cells 
with the target color to the new color.
   before (src is 1,1)     after
Key Ideas:
  Use DFS or BFS to traverse the region.
  Only visit cells with the same initial 
color.
  Avoid revisiting by checking or marking.
Example Challenge
39
â€¢A binary tree is represented 
using an array of Integer. 
Construct it.
public void buildTree( Integer[] nums) {
 BTNode root = new BTNode(nums[ 0]);
 Queue<BTNode> queue = new LinkedList <>();
 queue.offer(root);
 int i = 1;
 while (i < nums.length) {
  BTNode cur = queue.poll();
    
  if (i < nums.length && nums[i] != null) {
    cur.left = new BTNode(nums[i]);
    queue.offer(cur.left);
  }
  i++;
  if (i < nums.length && nums[i] != null) {
    cur.right = new BTNode(nums[i]);
    queue.offer(cur.right);        
  }
  i++;
}
  // this.root = root;
  // return root 
}Example Challenge
40
â€¢dumpToString 
â€¢printLevelOrder
public String dumpToString( /* BTNode root */ ) {
 StringBuilder  sb = new StringBuilder( "[");
 LinkedList <BTNode> q = new LinkedList <>();
 q.add(root);
 BTNode cur = root;
 while (!q.isEmpty()) {
  cur = q.removeFirst();
  if (cur == null) {
    sb.append( "null, " );
    continue ;
  }
  sb.append(cur.data).append( ",");
  q.add(cur.left);
  q.add(cur.right);
 }
 if (sb.length() >= 2)
   sb.setLength(sb.length() - 2); 
  // String result = sb.substring(0, sb.length() - 2);
 sb.append( "]");
 return sb.toString();
}[1,null, 2,3,null, null, null]Example Challenge
41
â€¢dumpToString  
â€¢printLevelOrder
public void printLevelOrder( BTNode root) {
 // if (root == null) return;
 Queue<BTNode> queue = new LinkedList <>();
 queue.offer(root);
 while (!queue.isEmpty()) {
  int levelSize = queue.size();
  for (int i = 0; i < levelSize; i++) {
    BTNode cur = queue.poll();
    System.out.print(cur.data + " ");
    if (cur.left != null)
          queue.offer(cur.left);
    if (cur.right != null)
          queue.offer(cur.right);
  }
  System.out.print( " ### ");
 }
 System.out.println();
}
1  ### 2  ### 3  ###Example Challenge
42â€¢Write a recursive method to perform 
an in -order traversal on a binary tree 
and return the traversal result as a 
single String. (StringBuilder is helpful 
for efficiency) 
String dfs(BTNode n) {
  StringBuilder  sb = new StringBuilder();
  dfs_inOrder(n, sb);
  return sb.toString();
}
void dfs_inOrder( BTNode n, StringBuilder  sb) {
  if (n == null) 
    return;
  dfs_inOrder(n.left, sb);
  sb.append(n.data).append( " ");
  dfs_inOrder(n.right, sb);
}
1  3  2Summary
â€¢Recursion is a problem -solving technique where you break a problem into 
identically smaller pieces problems .
â€¢Thus, you can call the same method to solve the problem ïƒŸrecursive
â€¢Each recursive call must be provided with smaller problem
â€¢The diminishing problem must approach its base case( s).
â€¢Recursion is a fundamental to Divide and Conquer Algorithm Strategy ! 
â€¢There is a tool for performing running time analysis  on recurrence algorithm!
â€¢There are single and multiple recursion.
â€¢Avoid multiple recursion where you have to solve the same sub -problem like 
Fibonacci.
â€¢Memoization  improves the time efficiency of the program by storing values such that, 
if required, the memory returns the stored value instead of recomputing the value.
â€¢Dynamic Programming  solves problems with bottom -up overlapped subproblems.
â€¢All recursive can be rewrite using loop(s) and stack(s)
â€¢Tail recursion can be rewrite without stack. 
43