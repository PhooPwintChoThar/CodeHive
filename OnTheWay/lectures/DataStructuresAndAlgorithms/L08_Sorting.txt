Sorting Primer
(kmitl) cs -departmentCh.08aOutline
â€¢Classical Intuitive Sorting 
Algorithm
â€¢Bubble sort
â€¢Selection sort
â€¢Insertion sort 
â€¢Classic Divide & Conquer 
(Comparison -based)
â€¢Quick sort
â€¢Merge sort
â€¢Example of non -comparison 
sorting algorithm 
â€¢Radix Sort
â€¢Counting sort 2
â€¢Using Data Structure
â€¢Heap sort
â€¢BST sortReasons for Sorting
â€¢Making lookup or search efficient;
â€¢Making merging of sequences efficient.
â€¢Enable processing of data in a defined order.
3Sorting Characteristics
â€¢Time efficiency 
â€¢If data are compared to each other internally before rearrange, the best we 
can do is O(n log n)  
â€¢since each rearrange takes O(n) and we must compare at least O(log n) time
â€¢Sometimes analyze comparing  and swapping  separately.
â€¢Memory requirement
â€¢Internal sort  means it requires no extra (external) memory.
â€¢Stability
â€¢Stable sort  means data with same key will not be re ordered. 
â€¢Sorting can de done by sorting data or sorting keys to data. 
â€¢For example, a title of a book can be the key to the book.
â€¢Stable Sorting works with requirements which primary key, secondary key, tertiary 
key, and so on are required.
â€¢Trivia 
â€¢Sorting Order : Ascending â†’ from low to high, Descending â†’ from high to low
4Well known in -place sorting algorithms
5
https://devopedia.org/sorting -algorithms  
Selection Sort
https://www.collegenote.net/curriculum/data -structures -and-algorithms/83/465/  Bubble Sort
â€¢Only for academic purpose, do not 
use it in practice!  
â€¢NaÃ¯ve bubbleSort()
â€¢All pair
â€¢Sweep and compare two data next to 
each other and swap if necessary. 
â€¢Improved bubble sort 
â€¢Repeat until no more swapping
https://sameer9247.wordpress.co
m/2016/11/15/sorting/  
6
https://www.researchgate.net/figure/Sequential -Bubble -
sort-Pseudocode_fig1_334131761  Bubble Sort: Pseudocode
7
Bubble Sort
â€¢Best case: O(n) comparisons, 
O(1) swaps
â€¢Worst case: O(n2) comparisons, 
O(n2) swaps
â€¢Average case: O(n2) 
comparisons, O(n2) swaps
â€¢Memory requirement: none
â€¢Stable: yes
8Selection Sort
â€¢Select the smallest key and put it in front
â€¢Very simple to understand and implement
9Selection Sort: Pseudocode
10Selection Sort
â€¢Best case: O(n2) comparisons , 
O(1) swaps
â€¢Worst case: O(n2) comparisons, 
O(n) swaps
â€¢Average case: O(n2) comparisons, 
O(n) swaps
â€¢Memory requirement: none
â€¢Stable: no
11Insertion Sort
â€¢Put the current key in place of 
sorted list
â€¢Sorted list starts from no element
and add in one at a time.
â€¢A list of size one is sorted
â€¢Has some usage in practice .
12Insertion Sort: Pseudocode
â€¢Without key, 
swap
â€¢With key, 
shift  instead 
of swap.
13Insertion Sort
â€¢Best case: O(n) comparisons, 
O(1) swap
â€¢Worst case: O(n2) 
comparisons, O(n2) swaps
â€¢Average case: O(n2) 
comparisons, O(n2) swaps
â€¢Memory requirement: none
â€¢Stable: yes
14Sorting non -trivia
â€¢Sorted data can be used for solving a number of applications.
â€¢Big-O of practical sorted algorithms is O(n log n)  
â€¢A number of use case to transform O(n2) problem to O(n log n) + O(n)  
by transforming the data to be sorted then solve it linearly.
â€¢bubble sort, selection sort, and insertion sort are intuitive â€“ not 
so complex. Hence they share the same big -O of O(n2) 
â€¢insertion sort has some application because itâ€™s real performance on 
small data tends to be good enough
â€¢Other efficiency factor should also be considered such as space 
required (non -in-memory sort)
15Do not forget other algorithm characteristics
â€¢All three algorithms are in-place  i.e. space complexity is O(1). 
â€¢If the data order is required after sorting, use only algorithms 
with stable  characteristic.
â€¢we can find improvements over intuitive sorting algorithms
â€¢Non-comparison sorting algorithms has been studied, proposed.
16
Sorting
(kmitl) cs -departmentCh.08bOutline
â€¢Recall
â€¢insertion sort, etc
â€¢Quicksort
â€¢Mergesort
â€¢Radix sort
â€¢Counting sort
â€¢Bucket sort
â€¢Shell sort  
â€¢Later
â€¢Heap sort, BST sort
18
Quick Sort
â€¢Invented by Tony Hoare in 1959, still 
commonly used today.
â€¢Nice example of divide -and-conquer 
algorithm
â€¢Start by select a pivot and divide to 2 lists: 
lower and higher lists.
19
https://slidetodoc.com/back -to-sorting -more -
efficient -sorting -algorithms -merge/  Quick Sort
20
https://slidetodoc.com/tutorial -4-the-quicksort -algorithm -
quick -sort-divide/  
https://www.techiedelight.com/quicksort/  Quick Sort: Pseudocode
21
Divide (Partitioning)
22https://en.ppt -online.org/77315  
 https://dl.acm.org/doi/fullHtml/10.1145/3274660  Quick Sort: Pseudocode
23
https://cis.temple.edu/~pwang/5511 -PT/Lecture/5511 -05.htm  
Quick Sort
â€¢Best case: O(n log n)
â€¢Worst case: O(n2)
â€¢Due to bad pivot
â€¢Best pivot is the median
â€¢But time to compute median is to long
â€¢Average case: O(n log n)
â€¢Memory requirement: O(log n)
â€¢Stable: no
24Merge Sort
â€¢Divides list into n sub -lists
â€¢Merge two sub -lists into 
one sorted sub -list 
â€¢This take O(n)
â€¢Repeat until all sub -lists are merged
25
https://www.zhangpengxiang.com/en/archives/2021/3/22 -Merge -Sort
Merge Sort
26
 https://www.jsums.edu/nmeghanathan/files/2019/01/CSC323 -Sp2019 -Module -2-Divide -and-Conquer.pdf  Merge Sort: 
Pseudocode
27
(Recursive) MergeSort Runtime Analysis
T(n) = 2T(n/2) + cn  ; n >= 2 
T(1) = 0 
Hence
Î˜(n log n) 
28Adapted from https://courses.cs.washington.edu/courses/cse521/13wi/slides/05dc.pdf  
Food of thought (on divide and conquer)
â€¢Suppose weâ€™ve dullSort with O(n2) 
â€¢ calling
 dullSort(first n/2 elements)
 dullSort(last n/2 elements)
 merge result
â€¢Analysis Running time: 2(n/2)2 + n = n2/2 + n  << n2 
â€¢Moral 1 : â€œtwo halves are better than wholeâ€
â€¢Moral 2 : â€œIf a littleâ€™s good, then moreâ€™s betterâ€
â€¢Moral 3 : â€œUnbalanced division less goodâ€ 
â€¢(0.1n)2 + (0.9n)2 + n = 0.82n2 + n // still 18% improvement 
29Adapted from https://courses.cs.washington.edu/courses/cse521/13wi/slides/05dc.pdf  // almost twice as fast!Merge Sort : Time complexity 
â€¢Best case: O(n log n)
â€¢Worst case: O(n log n)
â€¢Average case: O(n log n)
â€¢Memory requirement: O(n)
â€¢Stable: yes
3031
Comparison -based sorting librariesRadix Sort
â€¢Using â€œdigitsâ€ as buckets
â€¢Help reduce effect of m
32
Radix Sort
â€¢Best case: O( nd) â€“ d = ð‘™ð‘œð‘”10ð‘›
â€¢Worst case: O(nd)
â€¢Average case: O(nd)
â€¢Memory requirement: O(n+d)
â€¢Stable: yes
33
https://www.brainkart.com/article/Radix -sort_6986/  Counting sort  
â€¢Non-comparison sorting algorithm
â€¢It operates by 
â€¢counting the number of objects  that possess distinct key values, 
â€¢and applying prefix sum on those counts to determine the positions of 
each key value in the output sequence. 
â€¢Its running time is linear in the number of items and the difference between 
the maximum key value and the minimum key value
â€¢so it is only suitable for direct use in situations where the variation in 
keys is not significantly greater than the number of items. 
â€¢It is often used as a subroutine in radix sort , another sorting algorithm, 
which can handle larger keys more efficiently.
34Counting sort 
â€¢With prefix sum, the sort is 
stable !!
35Challenge 
36Bucket Sort
â€¢Put keys in their respective 
buckets,
then read them out one by one.
â€¢Example of external comparison 
sorting.
â€¢Thus, this may break O(n log n) lower 
bound.
â€¢Let talk about bucket sort for 
sorting list where each element is 
between [0..max].
37Bucket Sort: Pseudocode
â€¢Best case: O(n) â€“ m = n
â€¢Worst case: O(m+n)
â€¢Average case: O(m+n)
â€¢Memory requirement: O(m)
â€¢Stable: yes
38
https://javarevisited.blogspot.com/2017/01/bucket -sort-in-java-with -example.html  
Shell sort  
â€¢Shellsort  is an optimization of insertion sort  that allows the 
exchange of items that are far apart. 
â€¢The idea is to arrange the list of elements so that, starting 
anywhere, taking every hth element produces a sorted list (h 
interleaved lists). Such a list is said to be h -sorted and individualy 
sorted. 
â€¢Beginning with large values of h allows elements to move long 
distances in the original list, reducing large amounts of disorder 
quickly, and leaving less work for smaller h -sort steps  to do. 
â€¢Following this idea for a decreasing sequence of h values  ending 
in 1 is guaranteed to leave a sorted list in the end.
39Shell sort pseudocode 
40Shell sort application 
â€¢Shell Sort can be used for a variety of purposes, including:
â€¢Shell sort has a more significant cache miss percentage than quicksort 
and executes more operations.
â€¢Some versions of the qsort function in the C standard library geared at 
embedded devices utilize it instead of quicksort because it requires less 
code and does not use the call stack . The uClibc library, for example, 
uses Shell sort. The Linux kernel has a Shell Sort implementation for 
similar reasons.
â€¢Shell sort can also be used as a sub -algorithm of the introspective sort 
to sort short subarrays and avoid slowdowns when the recursion depth 
exceeds a certain threshold. This method is used in the bzip2 
compression algorithm, for example. 41Heap Sort
â€¢Put all keys in heap, then take it out one by one.
â€¢See binary heap video for detail
â€¢Best case: O(n log n)
â€¢Worst case: O(n log n)
â€¢Average case: O(n log n)
â€¢Memory requirement: O(n)
â€¢Stable: no
42Sorting :
The big picture  
43
â€¢https://www.cs.usfca.edu/~galles/visualization/ComparisonSort.html  
â€¢Sorting Algorithms in Wiki
44Recommended Resources
