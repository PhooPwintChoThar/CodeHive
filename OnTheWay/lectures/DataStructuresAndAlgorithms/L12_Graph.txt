Graph
(kmitl) cs -departmentCh.12
1Outline
•Graph definition
•Path
•Etc.
•Graph representation 
•Adjacency matrix
•Adjacenty list
•Subgraph & Minimum Spanning Tree (MST)
•Traversing Graph 
•Single Source Shortest Path
2Basic Graph Definitions
•A non -linear ADT where we care about entities and their 
connection(s)
•A graph  G = (V,E) consists of a finite set of vertices , V, and a finite set 
of edges , E. 
•Each edge is a pair ( v,w) where v, w  V.
•V and E are sets, so each vertex v  V is unique, and each edge e  E is 
unique.
•Edges are sometimes called arcs or lines .
•Vertices are sometimes called nodes  or points .
321
4 3Graph Interpretation
•The vertices could represent rooms  in a 
house, and the edges could indicate which 
of those rooms are connected  to each 
other.
•Vertices are cities  and edges are the roads  
connecting them.
•Edges are the components  in a circuit and 
vertices are junctions  where they connect.
•Vertices are software packages  and edges 
indicate those that can interact .
•Edges are phone conversations  and vertices 
are the households  being connected.Living Room      Den     Bedroom
    Kitchen        Hallway     Bath
by Eric Torng
Michigan State UniversityLiving                Den
Room
                     Hall
                                   Bed
    Kitchen    Bath
Apartment Blueprint
4Friendship Graphs
Auntie M.
Tin Man
The Wicked Witch
of the West
Each vertex represents a person, and each edge indicates that 
the two people are friends.Dorothy Scarecrow
Cowardly
    Lion
5Graph Basic Definition
•Directed and undirected graphs
•A graph is said to be undirected  if edge ( x, y)  always implies ( y, x).  
Otherwise, it is said to be directed .  Often called an arc.
•Loops, multiedges , and simple graphs
•An edge of the form ( x, x) is said to be a loop.  If x was y’s friend several 
times over, we can model this relationship using multiedges .  A graph is 
said to be simple  if it contains no loops or multiedges .
•Weighted edges
•A graph is said to be weighted  if each edge has an associated numerical 
attribute.  In an unweighted  graph, all edges are assumed to be of equal 
weight.
6Undirected / Directed Graph
◼ All edges are two -way.  Edges 
are unordered pairs.21
3 45
◼All edges are “one -way” as 
indicated by the arrows. Edges 
are ordered pairs.◼V = { 1, 2, 3, 4, 5}
◼E = { (1,2), (2, 3), (3, 4), (2, 4), (4, 5), (5, 1) }
1
5 2
3 4
7◼E = { (1, 2), (2, 4), (3, 2), (4, 3), (4, 5), (5, 4), (5, 1) }Basic Graph Definitions (2)
•Vertex w is adjacent to vertex v if and only if (v, w)  E. 
•For undirected graphs, with edge (v, w), and hence also (w, v), w 
is adjacent to v and v is adjacent to w.
•An edge may also have:
•weight  or cost -- an associated value
•label  -- a unique name
•The degree  of a vertex, v, is the number of vertices adjacent to v. 
Degree is also called valence .
•A sparse graph  is one with “few” edges. That is |E| = O( |V| )
•A dense graph  is one with “many” edges. That is |E| = O( |V|2 )
8Basic Graph Definitions (3)
•For directed graphs vertex w is adjacent  to vertex 
v if and only if (v, w)  E.
•Indegree  of a vertex w is 
the number of edges ( v,w).
•OutDegree  of a vertex w is 
the number of edges( w,v).1
5 2
3 421
3 45
9Recap
•Graphs are ADT which represent entities and their connections
•Entities and connections can be very abstract.
•Graphs can be directed/undirected, simple/multi -edges, 
weighted/unweighted.
•Graph with few edges, comparing to nodes, are call sparse graph. If 
there are a lot of edges comparing to nodes, we call them dense graph.
•Nodes can have other nodes that it’s adjacent to through edges.
•Degree of a node is the number of edges connected to the nodes.
•Degree can be in -degree and out -degree in case of directed graph.
10Some Graph
•Complete graphs
•Path graphs
•bipartite graphs
https://mathworld.wolfram.com/CompleteGraph.htmlhttps://www.geeksforgeeks.org/find -paths -given -source -destination/
https://www.educative.io/answers/what -is-a-bipartite -graph
11Paths in Graphs
•A path  in a graph is a sequence of vertices w1, w2,  …, wn such that ( wi, wi+1)  E for 1  i < n.
•The length  of a path in a graph is the number of edges  on the path. The length of the path 
from a vertex to itself is 0.
•A simple  path  is a path such that all vertices are distinct, except that the first and last may 
be the same.
•A cycle  in a graph is a path w1, w2, w3, …, wn , w  V such that:
•there are at least two vertices on the path
•w1 = wn  (the path starts and ends on the same vertex)
•if any part of the path contains the subpath  wi, wj, wi, then each of the edges in the subpath  is 
distinct ( i. e., no backtracking along the same edge)
•A simple  cycle  is one in which the path is simple.
•A directed graph with no cycles is called a directed  acyclic  graph , 
often abbreviated as DAG
12A Single Graph with Disjoint Set Example
76
9821
3 45•Disjoint  sets can be used to 
determine connected 
components of an 
undirected graph.
•For each edge, place its two 
vertices (u and v) in the same 
set -- i.e. union( u, v )
•When all edges have been 
examined, the forest of sets 
will represent the connected 
components.Sets representing connected components
 { 1, 2, 3, 4, 5 }
 { 6 }
 { 7, 8, 9 }
13Bipartite Graph
•A graph is bipartite if the nodes can be partitioned into two sets 
V1 and V2 such that all edges go only between V1 and V2 (no 
edges go from V1 to V1 or from V2 to V2)
•An NP -Hard problem
14Recap
•Path is a way to move from one node to another using edges
•Path can have length as number of edges
•Cycle mean we go back to the same node
•Simple path/cycle means we do not use the same edge twice
•Connected graph means there is at least one path connect any 
two nodes.
•For digraph, strongly connected require paths that obey the edge’s 
directions while weakly connected ignores the directions.
15A Graph Abstract Data Type (ADT)
•Has some data elements
•Vertices and Edges
•Has some operations
•getDegree ( u ) -- Returns the degree of vertex u (outdegree of vertex u 
in directed graph)
•getAdjacent ( u ) -- Returns a list of the vertices adjacent to   vertex u (list 
of vertices that u points to for a directed graph)
•isAdjacentTo ( u, v )  -- Returns TRUE if vertex v is adjacent to vertex u, 
FALSE otherwise.
•Has some associated algorithms to be discussed.
16Adjacency Matrix Implementation
•Uses array of size |V|  |V| where each entry ( i ,j) is boolean  
•TRUE if there is an edge from vertex i to vertex j
•FALSE otherwise
•store weights when edges are weighted
•Very simple, but large space requirement = O (|V|2)
•Appropriate if the graph is dense. 
•For example, if  a graph is used to represent a street map like Manhattan in which 
most streets run E/W or N/S, each intersection is attached to only 4 streets and |E|  < 
4*|V|.  If there are 3000 intersections, the table has 9,000,000 entries of which only 
12,000 are TRUE.
17Undirected Graph / Adjacency Matrix
12345
101001
210110
301010
401101
510010
21
3 45
18Directed Graph / Adjacency Matrix
12345
101000
200010
301000
400101
510010
1
5 2
3 4
19Weighted, Directed Graph / Adjacency Matrix
12345
102000
200060
307000
400302
580050
5 2
3 481
2
6
7
35
2
20Adjacency List Implementation
•If the graph is sparse, then keeping a list of adjacent 
vertices for each vertex saves space.  Adjacency Lists 
are the commonly used representation.  The lists may 
be stored in a data structure or in the Vertex object 
itself.
•Vector of lists : A vector of lists of vertices.  The i-th 
element of the vector is a list, Li, of the vertices adjacent 
to vi.
•If the graph is sparse, then the space requirement is 
O( |E| + |V| ), “linear in the size of the graph”
•If the graph is dense, then the space requirement 
is O( |V|2 )
215 2
3 481
2
6
7
35
2
2
4
3 51
2
3
4
5 1 42Graph Representation Comparison
Adjacency list Adjacency matrix
Storage O(|V|+|E|) O(|V|2)
Add vertex O(1) O(|V|2)
Add edge O(1) O(1)
Remove vertex O(|E|) O(|V|2)
Remove edge O(|E|) O(1)
Query: are vertices u, v adjacent? 
(Assuming that the storage positions 
for u, v are known)O(|V|) O(1)
RemarksWhen removing edges or 
vertices, need to find all 
vertices or edgesSlow for add/remove 
vertices, because matrix must 
be resized/copied
22Tradeoffs Between Adjacency Lists 
and Adjacency Matrices
•Comparison   Winner (for worst case)
•Faster to test if ( x, y) exists?  matrices : (1) vs. (V) 
•Faster to find vertex degree?   lists: (1) vs. (V)
•Less memory on sparse graphs?   lists: (V+E) vs. (V2)
•Less memory on dense graphs?  matrices: (small win)
•Edge insertion or deletion?   matrices : (1) vs. (V) (E)
•Faster to traverse the graph?  lists: (E+V)  vs. (V2)
•Better for most problems?  Lists ?
23Recap
•Graph can be represented in many ways. The most popular ones are 
adjacency matrix  and adjacency list .
• Adjacency matrix is good for a dense graph. A lot of operation can be 
fast, especially checking if u and v are connected. However, it may be 
impractical for large data.
•Adjacency list requires less space but slower in some operation. 
However, some operation can be faster. For example, listing 
connected nodes of the current node.
24Tree as a Sub -graph
•Tree  can be defined as a graph 
without cycle. 
•Sub-graph  of G is a graph where
 nodes and edges are subsets of 
nodes and edges of G
•Spanning Tree of G is a subgraph of 
G with contains all the vertices and 
all the vertices are connected with simple path.
•Minimum Spanning Tree  is a subset of the edges of 
a connected, edge -weighted undirected graph that 
connects all the vertices together, without any 
cycles and with the minimum possible total edge 
weight . 
25•G = (V,E)
•SPT = (V’, E’)
•V’ = V
•E’ ⊂ EMinimum Spanning Tree – MST 
•Can represent many applications 
such as network wiring, road 
building.
•There can be multiple  MST 
•If all edges have distinct weights, 
then the MST is unique
26
https://cseweb.ucsd.edu//~kube/cls/100/Lectures/lec14.spanning/lec14 -10.htmlFinding a Minimum Spanning Tree 
Kruskal’s Algorithm
•Create a forest where each node is a separate tree
•Make a sorted  list of edges  S
•While S is non -empty:
•Remove an edge with minimal weight
•If it connects two different trees, add 
the edge.  Otherwise discard it.
27
Finding a Minimum Spanning Tree 
Kruskal’s Algorithm
•Create a forest where each node is a separate tree
•Make a sorted  list of edges  S
•While S is non -empty:
•Remove an edge with minimal weight
•If it connects two different trees, add 
the edge.  Otherwise discard it.
28A
BC
D7
F
G7 8
85 5
69
15
119ERecap
•Finding minimal spanning tree is useful for urban planning and other 
application.
•Minimum spanning tree is not unique. 
•There are several ways to find MST. We discuss Krukal’s  Algorithm 
where we keep add the minimum cost edge as long as it doesn’t make 
a cycle. 
•Prim’s MST is left for exercise. 
•Recommended Reading: 
https://www.w3schools.com/dsa/dsa_theory_mst_minspantree.php  
29Traversing a Graph
•One of the most fundamental graph problems is to traverse every 
edge and vertex in a graph. Applications include: 
• Printing out the contents of each edge and vertex. 
• Counting the number of edges. 
• Identifying connected components of a graph. 
•For correctness , we must do the traversal in a systematic way so that 
we don't miss anything. 
•For efficiency , we must make sure we visit each edge at most twice . 
•Recall – tree traversal techniques are preOrder inOrder postOrder 
30Marking Vertices
•The idea in graph traversal is that we mark each vertex when we first visit it and 
keep track of what is not yet completely explored. 
•For each vertex, we maintain two flags: 
• discovered  - have we encountered this vertex before ? 
•Initially, only a single start vertex is set to be discovered. 
•Other vertices can be either retrieved or generate on the fly
• explored  - have we finished exploring this vertex? 
•Correctness of the algorithm
•Every edge and vertex in the connected component is eventually visited. 
•Suppose not, i.e. there exists a vertex which was unvisited whose neighbor 
was visited.  This neighbor will eventually be explored so we would  visit it….
31Traversal Orders
•The order we explore the vertices depends upon the data structure used to 
hold the discovered vertices yet to be fully explored: 
• Queue  - by storing the vertices in a first -in, first out (FIFO) queue, we explore the 
oldest unexplored vertices first. Thus we radiate out slowly from the starting vertex, 
defining a so -called breadth -first search . 
• Stack  - by storing the vertices in a last -in, first -out (LIFO) stack, we explore the 
vertices by constantly visiting a new neighbor if one is available; we back up only 
when surrounded by previously discovered vertices.  This defines a so -called depth -
first search .
•Correctness of the algorithm
•Every edge and vertex in the connected component is eventually visited. 
•Suppose not, i.e. there exists a vertex which was unvisited whose neighbor was visited.  
This neighbor will eventually be explored so we would  visit it….
32Breadth -First Search
•BFS characteristics
•Nodes being worked on maintained in a FIFO Queue , not a stack
•Iterative style  procedures often easier to design than recursive 
procedures
AD
B
LKJG
H
I
FCEPut root in a Queue
Repeat until Queue is empty
  Dequeue a node
  Process it
  Add it’s children to queue
33Breadth -First Search
AD
B
LKJG
H
I
FCEEnqueue(A)
dequeue
(A)
  A(B, C)
  B(C, D)
  C(D, E, F)
  D(E, F, G, H)
E    (F, G, H, I)
F    (G, H, I)
G     (H, I, J, K)
  H      (I, J, K)
  I      (J, K)
  J      (K)
  K      (L)
  L      ()
What if enqueue(B)?34
Breadth -First Traversal: Pseudocode
void bfs() {
Queue<Vertex> q;
Vertex u, w;
for all v in V, d[v] =  // mark each vertex unvisited
q.enqueue (startvertex ); // start with any vertex
d[startvertex ] = 0;  // mark visited
while ( ! q.isEmpty () ) {
  u = q.dequeue ( );
  for each Vertex w adjacent to u {
   if (d[w] == ) {  // w not marked as visited
     d[w] = d[u]+1;  // mark visited
      path[w] = u;   // where we came from
       q.enqueue (w);
   }
  }
}
}Put root in a Queue
Repeat until Queue is empty
  Dequeue a node
  Process it
  Add it’s children to queue
35Depth -First Search
Push root on a Stack
Repeat until Stack is empty
  Pop a node
  Process it
  Push it’s children to Stack
36AB
LKJG
H
I
FCEDpush(A)
pop()
       (A)
  A    (C, B)
  B    (C, D)
  D    (C, H, G, E)
  E    (C, H, G, I)
  I    (C, H, G, F)
  F    (C, H, G)
  G    (C, H, J, K)
  K    (C, H, J, L)
  L    (C, H, J)
  J    (C, H)
  H    (C)
  C    () 
What if push(B) before push(C)?37
https://artint.info/html1e/ArtInt_53. html  Depth -First Search (Order of nodes)Depth First Traversal: Pseudocode
void dfs() {
 for (each v  V)
  dfs(v)
}
void dfs(Vertex v) {
 if (!v.visited){
   v.visited  = true;
   for each Vertex w adjacent to v
  if ( !w.visited  )
   dfs(w)
 }
}•Recursive •Iterative (pre -order)
void dfs() {
 Vertex u, w; Stack<Vertex> s;
 s.push(startvertex);
 startvertex.visited = true;
 while ( !s.isEmpty() ) {
  u = s.pop();
  for each Vertex w adjacent to u {
   if (!w.visited) {
    w.visited = true;
    s.push(w);
  }
 }
}3839https://blog.goodaudience.com/solving -8-puzzle -using -a-algorithm -7b509c331288  Depth -First Search (Application)
Other Traverse Order
•Best First Search
•Explore the “best” discovered node first
•The best can be heuristic.
•Restricted breadth -first search:
•Explore few of the same level nodes before go deeper
40Recap
•Graph is a non -linear ADT. Thus, the order of nodes is not 
defined.
•There are 3 statuses of nodes: undiscovered, discovered, and 
explored (processed). 
•Since graph can be abstract, the undiscovered nodes may not even 
exist. 
•Typical traverse orders are breadth -first and depth -first which 
associate with queue and stack respectively.
41Shortest Path
•In graph theory, the shortest path problem is the problem of finding a path 
between two vertices (or nodes) in a graph such that the sum of the weights 
of its constituent edges is minimized.
•There are several algorithms for find the shortest path.
•Shortest paths can be :
•Single source shortest path
•All pairs shortst path
•Single source, single target shortest path
42Single Source Shortest Path
•Dijkstra's Algorithm find the 
shortest path from a node 
(called the "source node") 
to all other nodes in the graph
•Positive edge weights.
•Applications
•Graphs are directly 
applicable to real -world scenarios. 
For example, we could use graphs to model a transportation network where 
nodes would represent facilities that send or receive products and edges would 
represent roads or paths that connect them.
https://www.freecodecamp.org/news/dijkstras -shortest -path -algorithm -visual -introduction/https://en.wikipedia.org/wiki/Shortest_path_problem
43Basic of Dijkstra’s algorithm
1.Dijkstra's Algorithm basically 
starts at the node that you 
choose (the source node) and 
it analyzes the graph to find the 
shortest path between that node 
and all the other nodes in the graph.
2.The algorithm keeps track of the 
currently known shortest distance 
from each node to the source node  
and it updates these values if it finds 
a shorter path .
3.Once the algorithm has found the shortest path between the source node and 
another node, that node is marked as "visited" and added to the path.
4.The process continues until all the nodes in the graph have been added to the 
path. This way, we have a path that connects the source node to all other nodes 
following the shortest path possible to reach each node.
https://www.geeksforgeeks.org/shortest -path -properties/
44Basic of Dijkstra’s algorithm
1.To compute shortest path from A
2.Create 3 lists, dist, visited, and prev. Each records status of nodes in the graph.
•dist[v]   records the current min distance from A to v
•visited[v]  records as true after v has been used for dist
•prev[v]   records previous node before reaching v
3.Set dist[v] to infinity, except dist[A] = 0
4.Set visited[v] to false (unvisited)
While there are unvisited nodes :
 pick v with smallest (unvisited) dist[v], set visited[v] to true
 for all other unvisited u connected to v
  set dist[v] = min( dist[u], dist[v] + distance[v,u] )  
45Pseudocode
https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm
46Visualized Dijkstra 
•u = 0; Q = {0}
d = [0, ∞, ∞, ∞, ∞, ∞, ∞]
•u = 0; Q = {0}; v = {1,2} 
d = [0,2,6, ∞, ∞, ∞, ∞]
prev = [ ∞,0,0, ∞, ∞, ∞ , ∞]
•u = 1; Q = {2,3}; 
d = [0,2,6,7, ∞, ∞, ∞]
prev = [ ∞,0,0,1, ∞, ∞ , ∞]
47Visualized Dijkstra 
•u = 2; Q = {3}
d = [0,2,6,7, ∞, ∞, ∞]
prev = [∞,0,0,1, ∞, ∞ , ∞]
•u = 3; Q = {4,5}; 
d = [0,2,6,7,17,22, ∞]
prev = [ ∞,0,0,1,3,3, ∞]
48Visualized Dijkstra 
•u = 4; Q = {5,6}
d = [0,2,6,7,17,22,19]
prev = [ ∞,0,0,1,3,3,4]
•u = 5; Q = {6}; 
d = [0,2,6,7,17,22,19]
prev = [∞,0,0,1,3,3,4]
•u = 6; Q = {}; 
d = [0,2,6,7,17,22,19]
prev = [∞,0,0,1,3,3,4]
49•Note: If Edge(6,5) = 1
•u = 6; Q = {}; 
d = [0,2,6,7,17,( 19+1),19]
prev = [∞,0,0,1,3, 6,4]Recap
•Graphs are used to model connections between objects, people, or 
entities. They have two main elements: nodes and edges. Nodes 
represent objects and edges represent the connections between 
these objects.
•Dijkstra's Algorithm finds the shortest path between a given node 
(which is called the "source node") and all other nodes in a graph.
•This algorithm uses the weights of the edges to find the path that 
minimizes the total distance (weight) between the source node and all 
other nodes.
50