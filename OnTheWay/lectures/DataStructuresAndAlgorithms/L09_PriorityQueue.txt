Priority Queue
(kmitl) cs -departmentCh.09Outline
•Priority Queue 
•Heap (array -based heap) 
2Priority Queue (ADT)
•In computer science, a priority queue  is an 
abstract data -type where each element in a 
priority queue has an associated priority . In a 
priority queue, elements with high priority 
are served before elements with low priority.
•In some implementations, if two elements have 
the same priority, they are served in the same 
order in which they were enqueued. 
•a priority queue can be implemented with a heap  
or another method such as an ordered array.
•(adapted from 
https://en.wikipedia.org/wiki/Priority_queue ) 
3
https://www.programiz.com/cpp -
programming/priority -queue  Priority Queue
•Similar to queue, but with priority
•Given that the data to store are 7, 3, 5, 4, and 2, in that order.
•However, each data comes with priority , 
like the following,
and we must remove  them according to their priority, 
the queue might look like this
•Actually, we do not really care the internal structure. We only care that 
after we enqueue 7, 3, 5, 4, and 2 with the given priorities, the order of 
dequeue must be 4, 2, 7, 5, and 3, in that order.7
23
35
24
12
1
7
23
35
24
12
1
4Heap (Data Structure)
•In computer science, a heap  is a tree -
based data structure that satisfies 
the heap property: 
•In a max heap, for any given node C, if P 
is a parent node of C, then the key (the 
value) of P is greater than or equal to 
the key of C. 
•In a min heap, the key of P is less than 
or equal to the key of C. The node at 
the "top" of the heap (with no parents) 
is called the root node.
•(adapted from 
https://en.wikipedia.org/wiki/Heap_
(data_structure )) 
5
https://www.c -sharpcorner.com/article/binary -heap -in-c-sharp/  Heap (Implementation)
•Also known as binary heap .
•A binary tree where any node in the tree 
holds value lower than or equals to than 
its children ( or greater than or equals to 
in max heap ).
•Can be represented effectively using an 
array .
6Priority Queue Implementation
•Both array and linked list are possible, but not optimal.
Binary heap Binomial heap Fibonacci heap
7relevant binary key terms
•Because it is easier to visualized binary heap as a 
binary tree, some special form of binary tree are as 
follow.
•A Binary tree is a Perfect Binary Tree  in which all the internal 
nodes have two children and all leaf nodes are at the same level. 
•A complete binary tree  is a binary tree in which every level 
except the last level must be completely filled and all the leaf 
elements must lean towards the left (The last leaf element 
might not have a right sibling).
•(Note that) A binary tree is balanced  if the height of the 
tree is O(Log n) where n is the number of nodes (the 
difference between the heights of the left and right 
subtrees is at most 1).
8
Insert Operation [insert(8)]
8
8
11
8
107 7 7
7
11•Since binary heap is very balance. The height of 
the tree is log(n).
•Maximum number of compare and swap is the 
height of the tree.
•Thus, the insert operation takes O(log(n))  
time in average.
9Remove Operation [remove()]
188
8
1077
8
10187
8
107
7
18
1887
18 10•Also O(log(n))
Note that there is no 
guarantee that, with the same 
priority, the first data in is 
going to be the first data out 
(how to fix this?)
10Heap Visualization
•https://www.cs.usfca.edu/~galles/visualization/Heap.html
11Array representation
•Since heap is very balance, we can represent 
it efficiently using array.
•Left/right child and parent location
can be computed as follow. 
12Priority Queue Setup
MyPQueue.java
publicclassMyPQueue {
    MyMinHeap  heap = new MyMinHeap ();
    public void enqueue(int d) {
        heap.insert (d);
    }
    public int dequeue() {
        return heap.remove ();
    }
    public int front() {
        return heap.peek ();
    }
    public boolean isFull() {
        return heap.isFull ();
    }
    public boolean isEmpty() {
        return heap.isEmpty ();
    }
    public String toString () {
        // your code here
    }
}PQueueTester.java
publicclassPQueueTester {
publicstaticvoidmain(String[] args){
MyPQueue  queue = newMyPQueue ();
//yourcodehere
}
}MyMinHeap.java
publicclassMyMinHeap {
    int MAX_SIZE = 100;
    int heap[] = new int[MAX_SIZE];
    int size = 0;
    public void insert(int d) {…}
    public int remove() {…}
    public int peek() {…}
    public boolean isFull() {…}
    public boolean isEmpty() {…}
    public String toString () {…}
}your code here
13Heap Insert
public void insert(int d) {
  int p = size++;
  heap[p] = d;
  int parent = (p -1)/2;
  while( (p>0) && (heap[p]<heap[parent]) ) {
    swap(p, parent);
    p = parent;
    parent = (p -1)/2;
  }
}O(log(n))
14Swapping
void swap(int a, int b) {
    int temp = heap[a];
    heap[a] = heap[b];
    heap[b] = temp;
}
void swap(int a, int b) {
    heap[a] = heap[a]+heap[b];
    heap[b] = heap[a] -heap[b];
    heap[a] = heap[a] -heap[b];
}void swap(int a, int b) {
    heap[a] = heap[a]*heap[b];
    heap[b] = heap[a]/heap[b];
    heap[a] = heap[a]/heap[b];
}
void swap(int a, int b) {
    heap[a] = heap[a]^heap[b];
    heap[b] = heap[a]^heap[b];
    heap[a] = heap[a]^heap[b];
}
15publicintremove() {
intd=heap[0];
heap[0]=heap[--size];
        heap[size] = d; //keep root value at the unused space
intp=0;
while(true){
intleft=2*p+1;
if(left>=size) break;//nochild
intright=2*p+2;
if(right==size) {//onechild
if(heap[p]>heap[left])
swap(p,left);
break;//nomorechild,
                       // nothing todo
}else{//twochilds
intq=heap[left]< heap[right]?left:right;
if(heap[p]>heap[q]) swap(p,q);
elsebreak;
p=q;
}
}//endwhile
returnd;
}Heap 
RemoveO(log(n))
16•In a binary heap, the delete 
operation is usually 
defined only for the root 
(e.g., extract -min in a min -
heap). 
•However, in theory, an 
arbitrary node can also 
be deleted by replacing it 
with the last element in 
the heap and then 
restoring the heap 
property using either sift -
up or sift -down. This 
ensures the heap 
structure and ordering 
properties are preserved .publicintremove() {
intd=heap[0];
heap[0]=heap[--size];
        heap[size] = d; //keep root value at the unused space
intp=0;
while(true){
intleft=2*p+1;
if(left>=size) break;//nochild
intright=2*p+2;
if(right==size) {//onechild
if(heap[p]>heap[left])
swap(p,left);
break;//nomorechild,
                       // nothing todo
}else{//twochilds
intq=heap[left]< heap[right]?left:right;
if(heap[p]>heap[q]) swap(p,q);
elsebreak;
p=q;
}
}//endwhile
returnd;
}Heap 
Remove
17Case 1: No child (delete 9) 
          1
       /     \
      3       6
     / \     /
   5    9   8         1
       /     \
      3       6
     / \
   5    8publicintremove() {
intd=heap[0];
heap[0]=heap[--size];
        heap[size] = d; //keep root value at the unused space
intp=0;
while(true){
intleft=2*p+1;
if(left>=size) break;//nochild
intright=2*p+2;
if(right==size) {//onechild
if(heap[p]>heap[left])
swap(p,left);
break;//nomorechild,
                       // nothing todo
}else{//twochilds
intq=heap[left]< heap[right]?left:right;
if(heap[p]>heap[q]) swap(p,q);
elsebreak;
p=q;
}
}//endwhile
returnd;
}Heap 
Remove
18Case 2: One child (delete 6) 
          1
       /     \
      3       6
     / \     /
    5   9   8         1
       /     \
      3       8
     / \
   5    9publicintremove() {
intd=heap[0];
heap[0]=heap[--size];
        heap[size] = d; //keep root value at the unused space
intp=0;
while(true){
intleft=2*p+1;
if(left>=size) break;//nochild
intright=2*p+2;
if(right==size) {//onechild
if(heap[p]>heap[left])
swap(p,left);
break;//nomorechild,
                       // nothing todo
}else{//twochilds
intq=heap[left]< heap[right]?left:right;
if(heap[p]>heap[q]) swap(p,q);
elsebreak;
p=q;
}
}//endwhile
returnd;
}Heap 
Remove
19Case 3: One child (delete 1) 
          1
       /     \
      3       6
     / \     /
    5   9   8         3
       /     \
      5       6
     / \
   8    9Other Kinds of Heap (from Wikipedia)
20•There are more advance data 
structures for priority queue 
implementation such as binomial 
heap, Fibonacci heap, which 
gives better amortized time 
complexity. They are too 
advance for this class.
Binomial heap Fibonacci heapRemark on heap
21•Heapify  
•If you start with an empty heap and insert n elements one by one:
•Each insertion is O(log n) in the worst case (percolating up along the heap height).
•Doing this n times = O(n log n) total.
•When we "heapify"  an array of size n, We treat the array as a binary tree 
stored in an array and enforce the heap property from bottom up:
•most nodes are shallow (leaves and near leaves), so only a few nodes pay large 
O(log n) cost. The amortized  cost per node is constant → O(n) overall.
•By repeatedly removing the root element (via poll()) from a heap until it is 
empty, we obtain the elements in sorted order. This procedure is known as 
Heap Sort . Example Challenge
22
Example Challenge
23
Example Challenge
24Implement a class which, for a given integer k, 
maintains a stream of test scores and 
continuously returns the kth highest test score 
after a new score has been submitted.
Summary
•Priory Queue is an ADT like a queue, but data out according to 
priority. 
•Operations are the same as queue.
•Can be implemented using heap, another ADT, and other kind of 
heap. 
•Typically, heap is not guarantee that, with the same priority, the first 
data in is going to be the first data out.
25