Queue
(kmitl) cs -departmentCh.06Outline
•Queue as a class
•Queue Implementation :
Linked List
•Queue Implementation :
Array 
•Shunting -yard Algorithm
2Queue – Another basic ADT
•Same as queue in real life
•enter one end, exit another
•First In, First Out – FIFO  
•Operations:
•Requires
•void enqueue(int d)
•int dequeue()
•Nice to have
•int front()
•Utility
•boolean isFull()
•boolean isEmpty()
•String toString()
3MyQueue.java
MyQueue.java
publicclassMyQueue {
    public void enqueue(int d) {
        // your code here
    }
    public int dequeue() {
        // your code here
    }
    public int front() {
        // your code here
    }
    public boolean isFull() {
        // your code here
    }
    public boolean isEmpty() {
        // your code here
    }
    public String toString () {
        // your code here
    }
}QueueTester.java
publicclassQueueTester {
publicstaticvoidmain(String[] args){
MyQueue queue = newMy Queue();
//yourcodehere
}
}
Must be O(1)
45Queue: Linked List Implementation
•Need to take out from the front, put in at the end.
•Remove from head takes O( 1) 
•Either Insert or remove via head takes O(1) -> think of stack push 
operation 
•However, remove from tail takes O(n)
•Insert to tail is O( 1)
•Attribute tail is required 3
2 87
4head
tail
5enqueue(int d)
public void enqueue(int d) {
    Node p = new Node(d);
    if(head==null) 
        head=tail=p;
    else {
        tail.next  = p;
        tail = tail.next ;
    }
}Must be O(1)!MyQueueL.java
publicclassMyQueueL{
    public class Node {
        int data;
        Node next;
        public Node(int d) {
            data = d;
        }
    }
    Node head=null, tail;
    // your code here
}
6dequeue()/front()
public int front() {
    return head.data ;
}public int dequeue() {
    int d = head.data ;
    head = head.next ;
    return d;
}
Both must be O(1)!4
tailhead
What will happen 
when dequeue this?
7isFull ()/isEmpty ()
public boolean isFull() {
    return false;
}
public boolean isEmpty() {
    return head==null;
}
8Queue: Array Implementation
•dequeue() = remove from head is O(n)
•How can we fix this?
•Well, we can move head.
•enqueue(int d) = Add to tail is O( 1)
•enqueue (2)
•Now, can we enqueue here?
•We need to fix it again.7 3 5 4tail
3 5 4 2tail
3 5 4 2 8headheadhead
tail
9Circular Array
•Move to next element
•n=(n+1) %MAX_SIZE3 5 4 2 8tail head
5 4 2 8head dequeue()
7 5 4 2 8tail enqueue(7)
7 3 5 4 2 8
tailhead enqueue(3)head
tail
Can you tell the different?Empty queueVery full queueheadtail
10enqueue()/dequeue()/front()
public void enqueue(int d) {
    queue[tail]=d;
    tail = (tail+1)%MAX_SIZE;
}
All must be O(1)!
public int dequeue() {
    int d = queue[head];
    head = (head+1)%MAX_SIZE;
    return d;
}public int front() {
    return queue[head];
}
11isFull ()/isEmpty ()
public boolean isFull() {
    return ((tail+1)%MAX_SIZE)==head;
}
public boolean isEmpty() {
    return head==tail;
}tail head
head
tail7 5 4 2 8
12Summary
•Queue is an ADT where first data in is the first data out.
•Require Operations are enqueue  and dequeue while front  is a nice 
to have.
•Queue can be implemented using array and linked list. 
•Next, let see some application of queue.
13Shunting -yard AlgorithmShunting -yard Algorithm
•Recall : Reverse Polish Notation
•Also known as postfix
•Ex: 5+3*4/(7 -(2-1)) can be written as 
5 3 4 * 7 2 1 --/ +
•We can compute postfix easily using stack
•How long would it take you to write a 
program to compute an infix expression of 
5+3*4/(7 -(2-1))?
•Shunting -yard Algorithm
•Invented by Edsger W. Dijkstra in 1961 
•Describes a way to convert infix 
expression to postfix  one.
•It works similar to a shunting yard of trains
15Simple Example
3 + 4 * ( 7 – 5 )
16Simple Example
3 + 4 * ( 7 – 5 ) 3 4 7 5 - * +
-
(
*
+/
17Simple Example
3 + 4 * ( 7 – 5 ) 3 4 7 5 - * +
-
(
*
+/ /
18Simple Example
3 + 4 * ( 7 – 5 ) 3 4 7 5 - * +
-
(
*
+/ / /
19Simple Example
3 + 4 * ( 7 – 5 ) 3 4 7 5 - * +
-
(
*
+/ / / /
20Simple Example
3 + 4 * ( 7 – 5 ) 3 4 7 5 - * +
-
(
*
+/ / / / /  
21Simple Example
3 + 4 * ( 7 – 5 ) 3 4 7 5 - * +
-
(
*
+/ / / / / /
22Simple Example
3 + 4 * ( 7 – 5 ) 3 4 7 5 - * +
-
(
*
+/ / / / / / / 
23Simple Example
3 + 4 * ( 7 – 5 ) 3 4 7 5 - * +
-
(
*
+/ / / / / / / / 
24Simple Example
3 + 4 * ( 7 – 5 ) 3 4 7 5 - * +
-
(
*
+/ / / / / / / / / 
/
/
25Simple Example
3 + 4 * ( 7 – 5 ) 3 4 7 5 - * +
-
(
*
+/ / / / / / / / / 
/
/
/
/
26Shunting -yard Algorithm Pseudocode
1. While there are tokens to be read:
2.         Read a token
3.         If it's a number add it to queue
4.         If it's an operator
5.                While there's an operator on the top of the stack with greater or equal precedence :
6. Pop operators from the stack onto the output queue
7. Push  the current operator onto the stack
8.         If it's a left bracket push it onto the stack
9.         If it's a right bracket 
10.             While there's not a left bracket at the top of the stack :
11. Pop operators from the stack onto the output queue.
12. Pop the left bracket from the stack and discard it
13. While there are operators on the stack, pop them to the queue
27Shunting -yard Algorithm Pseudo 
Implementation
Given stack s, queue q
While more token t:
  case t is a number:
    q.enqueue (t)   
  case t is an operator:
    while s.top()>t:
      q.enqueue (s.pop())
    s.push(t)
  case t is "(":
    s.push(t)case t is ")":
    while s.top()!="(":
      q.enqueue (s.pop())
    s.pop()
While !s.isEmpty ():
  q.enqueue (s.pop())
28Shunting -yard Algorithm Analysis
Given stack s, queue q
While more token t:
  case t is a number:
    q.enqueue (t)   
  case t is an operator:
    while s.top()>t:
      q.enqueue (s.pop())
    s.push(t)
  case t is "(":
    s.push(t)case t is ")":
    while s.top()!="(":
      q.enqueue (s.pop())
    s.pop()
While !s.isEmpty ():
  q.enqueue (s.pop())n rounds
n rounds
O(n)
29Shunting -yard Algorithm + RPN
•Start from infix
•Passing infix to Shunting -yard
algorithm
•Passing output queue
to RPN computation
•All can be done in O(n)
where n is the number
of token.
3 + 4 * ( 7 – 5 ) 3 4 7 5 - * +
11
30Example challengepublic void floodFill( int[][] image, 
                      int sr, int sc, int newColor) {
 int targetColor = image[sr][sc];
 if (targetColor == newColor) return;
 int rows = image.length, cols = image[ 0].length;
 Queue<int[]> queue = new LinkedList <>();
 queue.offer( new int[]{sr, sc});
 int[][] dirs = {{ 0,1}, {1,0}, {0,-1}, {-1,0}};
 while (!queue.isEmpty()) {
   int[] cell = queue.poll();
   int r = cell[ 0], c = cell[ 1];
   if (image[r][c] != targetColor) continue ;
   image[r][c] = newColor;
   for (int[] d : dirs) {
     int nr = r + d[ 0], nc = c + d[ 1];
     if (nr >= 0 && nr < rows && nc >= 0 && nc < cols
                         && image[nr][nc] == targetColor) {
       queue.offer( new int[]{nr, nc});
     }
   }
 }
}31Flood Fill Algorithm
Given a 2D grid (image), a starting cell (sr, 
sc), a target color, and a new color, 
replace all 4 -directionally connected cells 
with the target color to the new color.
   before (src is 1,1)     after
Key Ideas:
  Use DFS or BFS to traverse the region.
  Only visit cells with the same initial 
color.
  Avoid revisiting by checking or marking.
Example challengepublic class L06_IsExitExist {
 public boolean hasExit( int [][] grid, int startX, int startY) {
  // if (grid[startX][startY] != 0) return false;
  int rows = grid.length, cols = grid[ 0].length;
  boolean[][] visited = new boolean[rows][cols];
  Queue<int []> queue = new LinkedList <>();
  queue.offer( new int[] {startX,startY});
  visited[startX][startY] = true;
                     // north, east, south, west
  int[][] directions = {{ -1,0},{0,1},{1,0},{0,-1}}; 
  int [] cur;  int x,y;
  while (!queue.isEmpty()) {
   cur = queue.poll();
   x = cur[ 0]; y = cur[ 1];
   if (grid[x][y] == 2) return true;
   int nxtX, nxtY;
   for (var dir : directions) {
    nxtX = x + dir[ 0]; // cur[0] + dir[0];
    nxtY = y + dir[ 1]; // cur[1] + dir[1];     
     if (isInbound(nxtX,nxtY,rows,cols) 
              && !visited[nxtX][nxtY] 
              && (grid[nxtX][nxtY] == 0 || grid[nxtX][nxtY] == 2)) {
      queue.offer( new int[] {nxtX,nxtY});
      visited[nxtX][nxtY] = true;
    }
    } 
   }
  return false;
 }
}32Exit Detection in Connected Area 
Using BFS
Given a 2D grid where: 1 represents a 
wall, 0 represents open space, and 2 
represents an exit.
Starting from a given open cell (0), 
implement hasExit() to determine 
whether there exists  a path to the exit 
(2) by moving only through open cells (0) 
in four directions (up, down, left, right). 
The exit is guaranteed to be reachable 
from open space and adjacent to at least 
one 0.
Summary
•Shunting -yard algorithm is an interesting application of stack and 
queue.
•Shunting -yard algorithm and RPN computation can work 
together to compute infix expression in O(n)
33