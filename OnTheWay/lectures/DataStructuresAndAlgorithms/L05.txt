Stack
(kmitl) cs -departmentCh.05
This is not the stack ADT!Outline
•Introduction
•Stack: Array Implementation 
•Stack: Linked List 
Implementation 
•Some interesting application.
(Reverse Polish Notation - RPN)
2Introduction : 
Stack 
•A collection of data where you can 
add/remove a data to/from its top. 
•This make the last data in become 
the first data out. 
•Sometimes referred to as LIFO  
– last in , first out data structure
•There are two main operations in 
stack
•Push  – put a data on the stack 
•Pop – take a data  out of stack
•With one convenient operation
•Top – take a look at the data on the top of stack
Note : stack overflow is an error occurred when trying to put a data to a full stack.
https://www.collegenote.net/pastpapers/2898/question/
3MyStack.java
MyStack.java
publicclassMyStack {
    public void push(int d) {
        // your code here
    }
    public int pop() {
        // your code here
    }
    public int top() {
        // your code here
    }
    public boolean isFull() {
        // your code here
    }
    public boolean isEmpty() {
        // your code here
    }
    public String toString () {
        // your code here
    }
}StackTester.java
publicclassStackTester {
publicstaticvoidmain(String[] args){
MyStack stack=new MyStack();
//yourcodehere
}
}
Must be O(1)
4Stack Usage: Decimal to Binary Conversion
•To convert decimal to 
binary
we have to  keep divide the 
decimal 
by two and record the 
remainders.
•Then, the result binary can 
be read from
the remainders in reverse 
order.
•We can put the remainders 
in a list and reverse..
•Or we can use Stack!
public printBinary (int decimal) {
    Stack s = new Stack;
    while(decimal>0) {
        s.push(decimal%2);
        decimal/=2;
    } 
    while(!s.isEmpty ()) {
       System.out.print (s.pop());
    }
}decimal=decimal/ 2;
=
decimal=decimal>> l;
=
decimal>>=l;
5Stack: Array Implementation 
•Recall Array Add
•Pushing on a stack is
like add to an array.
•Popping from a stack
is just taking out (delete)
the last data and return.
•Required operations
void push(int d)
int pop()
•Convenient operation
int top()
•Utility operations
boolean isFull()
boolean isEmpty()
String toString()
MyStackA.java
publicclassMyStackA {
    int MAX_SIZE = 100;
    int stack[] = new int[MAX_SIZE];
    int top = 0;
    // your code here
}6push()/pop()
public void push(int d) {
    stack[top++] = d;
}
public int pop() {
    return stack[ --top];
}Again, must be O(1)!
7top()
public int top() {
    return stack[top -1];
}Method  top() and variable top  have 
the same name. 
Valid, but not very good practice.
8isFull ()/isEmpty ()
public boolean isFull() {
    return top==MAX_SIZE;
}
public boolean isEmpty() {
    return top==0;
}Stack overflow
Stack underflow(?)
9Recap
•Array implementation of stack is very simple.
•Look like simpler version of MyArray .
•Next : 
•Linked List implementation. 
•Some interesting application.
10•Recall Linked List add()
•Now, how to remove it from the same end?5 3
2 87
4head
publicvoidadd(int d){
Nodep=newNode(d);
p.next=head;
head=p;
}Stack: Linked List Implementation 
MyStackL.java
publicclassMyStackL {
    public class Node {
        int data;
        Node next;
        public Node(int d) {
            data = d;
        }
    }
    Node top=null;
    // your code here
}
11push()/pop()
public void push(int d) {
    Node p = new Node(d);
    p.next = top;
    top = p;
}
public int pop() {
    int d = top.data ;
    top = top.next ;
    return d;
}Again, must be O(1)!
12isFull ()/isEmpty ()
public boolean isFull() {
    return false;
}
public boolean isEmpty() {
    return top==null;
}Stack overflow(?)top()
public int top() {
    return top.data ;
}
13Reverse Polish Notation - RPN
•In 1954, Arthur Burks, Don Warren, and Jesse 
Wright proposed Reverse Polish Notation (RPN). 
•Put number first to reduce memory and make use 
of stack
•Ex: 3 * (10 + 5)  becomes 3 10 5 + *
•Aka. Polish postfix notation, postfix  notation.
•In 1924, Jan Łukasiewicz invented Polish Notation. 
•It is  a way to write mathematical expression 
without parenthesis. (Prefix notation)
•Ex: (3 -1)*(4+5) can be rewritten as * - 3 1 + 4 5
•HP and other company adopted RPN  and build applications and
calculators to help engineer with expression calculation .
Note that both notation require every that operator takes 
fix number of operands in order to  compute correctlypain point
https://mrtan.me/post/19.html
14Expression Tree
Only infix need parenthesis
15Infix to Postfix Conversion: Visual Method
•Example Infix: A + B * C  
•Step -by-Step Conversion: 
1.Fully Parenthesize the Expression. (Add parentheses to show precedence)
( A + ( B * C ) )
•Notice that each operator is between its operands and enclosed in 
parentheses.
2.Postfix Rule (Operators to the Right ): Move the operator to the right of its 
operand pair, and  remove parentheses. 
•( B * C ) → B C *
•( A + (B C *) ) → A B C * +
•Final Postfix : A B C * +
16How to Compute RPN
•Given a list of token t in a form of RPN.
•Ex: 3 5 + the tokens are 3, 5, and + and they are in the form of RPN
•The following pseudocode can evaluate the result
Create a stack s
While there are more tokens
  t = next token 
  case t is a number
    s.push(t)
  case t is an operator opr
    b = s.pop()
    a = s.pop()
    s.push(a opr b)
result = s.pop()
return result
17An Example
Given a list of tokens: 8 5 –  4 2 + 3 / *
1.t=8, s.push (8)
•Stack: top -> 8 -> bottom
2.t=5, s.push (5)
•Stack: top -> 5 -> 8 -> bottom
3.t= –, b=s.pop (), a= s.pop (), s.push (a-b)
•Stack: top -> 3 -> bottom
4.t=4, s.push (4)
•Stack: top -> 4 -> 3 -> bottom
5.t=2, s.push (2)
•Stack: top -> 2 -> 4 -> 3 -> bottom6.t=+, b= s.pop (), a= s.pop (), s.push (a+b)
•Stack: top -> 6 -> 3 -> bottom
7.t=3, s.push (3)
•Stack: top -> 3 -> 6 -> 3 -> bottom
8.t=/, b= s.pop (), a= s.pop (), s.push (a/b)
•Stack: top -> 2 -> 3 -> bottom
9.t=*, b=s.pop (), a= s.pop (), s.push (a*b)
•Stack: top -> 6 -> bottom
10.result s.pop(), return result
•Stack: top -> bottom
18Implementation: Testing StringTokenizer
ComputeRPN.java
import java.util.Scanner ;
import java.util.StringTokenizer ;
public class ComputeRPN  {
    public static void main(String[] args) {
        MyStack stack = new MyStack();
        Scanner in = new Scanner(System.in);
        String rpn = in.nextLine ();
        StringTokenizer  st = new StringTokenizer (rpn);
        
        while(st.hasMoreTokens ()) {
            String t = st.nextToken ();
            System.out.println (t);
        }
        in.close ();
    }
}
19Implementation: Testing isNumeric
import java.util.Scanner ;
import java.util.StringTokenizer ;
import java.util.regex.Pattern ;
public class ComputeRPN  {
private static Pattern pattern = Pattern.compile ("-?\\d+(\\.\\d+)?");
    public static boolean isNumeric (String strNum) {
        if (strNum == null) {
            return false; 
        }
        return pattern.matcher (strNum).matches();
    }
      public static void main(String[] args) {
          MyStack stack = new MyStack();
          Scanner in = new Scanner(System.in);
          String rpn = in.nextLine ();
          StringTokenizer  st = new StringTokenizer (rpn);
        
          while(st.hasMoreTokens ()) {
               String t = st.nextToken ();
          System.out.println (t+" is a number -> "+isNumeric (t));
          }
          in.close ();
      }
}
 20Implementation: 
while(st.hasMoreTokens ()) {
    String t = st.nextToken ();
    if(isNumeric (t)) 
        stack.push (Double.parseDouble (t));
    else {
        if(t.equals ("-")) {
            double b = stack.pop ();
            double a = stack.pop ();
            stack.push (a-b);
        }// else ...your code here...
    }
}
System.out.print ("result: "+ stack.pop ());
21Example challengepublic class Solution {
 public String makeGood( String str) { 
  // beat 55.50%
  Stack<Character > stack = new Stack<>();
  char ch, tmp = '/'; // dummie
  for (int i = 0; i < str.length(); i++) {
    ch = str.charAt(i);
    if (stack.isEmpty()) {
      stack.push(ch);
      continue ;
    }
    tmp = stack.peek();
        // lower -case vs upper -case
    if (Math.abs(tmp - ch) == 32) { 
      stack.pop();
      continue ;
    }
    stack.push(ch); 
  }
  StringBuilder  sb = new StringBuilder();
  while (!stack.isEmpty()) {
    sb.append(stack.pop());
  }
  return sb.reverse().toString();  
 }
} 22
Summary
•Stack is a linear ADT in which the insertion and deletion operations 
are performed at only the end.
•Top/Tail
•Its compulsory methods are .pop() and .push()
•Very useful method is .top()
•Utilities methods are .isFull(), .isEmpty(), .toString(), etc.
•Array or Linked List underlying data structure is demonstrated on 
implementing stack
•The LIFO characteristic of a stack can be used for solving many 
computer science problems.
23